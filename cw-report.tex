\documentclass[14pt]{extreport}
\usepackage{indentfirst}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\addto\captionsrussian{%
	\renewcommand{\contentsname}{Содержание}%
}
\addto\captionsrussian{%
	\renewcommand{\bibname}{Список литературы}%
}
\usepackage[top = 20mm, left = 30mm, right = 15mm, bottom = 20mm]{geometry}
\setlength\parindent{12.5mm}
\renewcommand{\baselinestretch}{1.5}
\def\hrf#1{\hbox to#1{\hrulefill}}
\usepackage{ragged2e}
\usepackage{caption}
\usepackage{multicol}
\usepackage{mathtools}
\usepackage{url}
\usepackage{xurl}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{courier}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{courier}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{float}

\renewcommand\thesection{\arabic{section}}

% Цвета для подсветки
\definecolor{bluekeywords}{rgb}{0.125,0.375,0.625}
\definecolor{greencomments}{rgb}{0.125,0.5,0.125}
\definecolor{redstrings}{rgb}{0.875,0.125,0.125}
\definecolor{graynumbers}{rgb}{0.5,0.5,0.5}
\definecolor{lightgray}{gray}{0.95}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

% Макрос для кода (Courier + серый фон)
%\usepackage{tgcursor}  % делает \texttt = TeX Gyre Cursor (аналог Courier)
\newcommand{\code}[1]{\colorbox{lightgray}{\texttt{#1}}}


\lstset{
	language=C++,
	basicstyle=\ttfamily\small,
	keywordstyle=\color{bluekeywords}\bfseries,
	commentstyle=\color{greencomments},
	stringstyle=\color{redstrings},
	numberstyle=\color{graynumbers},
	numbers=left,
	numbersep=10pt,
	columns=fullflexible,
	tabsize=4,
	showspaces=false,
	showstringspaces=false,
	breaklines=true,
	backgroundcolor=\color{lightgray},
	frame=single,
	rulecolor=\color{gray!30!black},
	captionpos=b
}


\begin{document}
	\sloppy
	\thispagestyle{empty}
	\centering{
		Министерство образования и науки Российской Федерации\\
		Федеральное государственное автономное образовательное учреждение высшего образования\\
		«Санкт-Петербургский политехнический университет Петра Великого»\\[10pt]
		Институт компьютерных наук и кибербезопасности\\
		Высшая школа технологий искусственного интеллекта\\
		02.03.01 Математика и компьютерные науки\\
		\vspace{\fill}
		{\large
			Отчёт по дисциплине\\
			{\Large \bf Дискретная математика\\Курсовая работа}\\
			{\Large <<Калькулятор конечной арифметики $Z_8$}>>}
			\vspace{\fill}
		}
		
		\flushright
		{
			{\bf Выполнил:}\\
			студент группы 5130201/40003\\
			Джабраилов А.В.\\
			{\bf Принял:}\\
			Востров А.В.\\
			<<\hrf{2em}>> \hrf{6em} 2025~г.
		}
		
		\centering{
			Санкт-Петербург, 2025
		}
		
		\newpage
		\justifying
		\tableofcontents
		
		\newpage
		\section*{Введение}
		\addcontentsline{toc}{section}{Введение}
		\subsection*{Актуальность и цель работы}
		%\addcontentsline{toc}{subsection}{Актуальность и цель работы}
		Использование кода Грея позволяет минимизировать количество ошибок при переходе от одного состояния к другому, что применяется, например, в кодировании данных.
		Мультимножества позволяют описывать системы, где элемент может встречаться несколько раз — это востребовано в базах данных, статистике и других областях.
		
		Таким образом, разработка программного инструмента, который демонстрирует генерацию кода Грея и операции над мультимножествами, способствует формированию навыков работы с дискретными структурами данных и алгоритмами, а также помогает на практике закрепить фундаментальные понятия теории множеств.
		
		
		\newpage
		\section{Постановка задачи}
		
		В рамках лабораторной работы необходимо реализовать калькулятор "большой" конечной арифметики $<Z_i;+,*>$ (8 разрядов) для четырех действий (+, -, *, /) на основе "малой" конечной арифметики, где задано правило «+1» и выполняются свойства коммутативности (+,*), ассоциативности (+, *), дистрибутивности * относительно +, заданы аддитивная единица «a» и мультипликативная единица «b», а также выполняется свойство: $(\forall x) х*a=a$. 
		
		Цель данной работы — реализовать программу, которая:
		\begin{itemize}
			\item поддерживает сложение для данной арифметики,
			\item поддерживает разность для данной арифметики,
			\item поддерживает умножение для данной арифметики,
			\item подддерживает деление для данной арифметики,
			\item поддерживает мультиразрядность (возможна операция bbb + ccc).
		\end{itemize}
		
		\newpage
		
		
		\section{Математическое описание}
		
		\subsection{Исходная структура — «малая» конечная арифметика}
		
		Рассмотрим конечное множество
		\[
		Z_8 = \{a, b, c, d, e, f, g, h\},
		\]
		на котором задана операция «+1», определяющая правило перехода от элемента к следующему:
		\[
		\begin{array}{c|cccccccc}
			x      & a & b & c & d & e & f & g & h \\ \hline
			x + 1  & b & d & e & h & g & a & f & c
		\end{array}
		\]
		
		Это правило задаёт циклическую аддитивную структуру порядка 8. Элемент $a$ является \textbf{аддитивной единицей}:
		\[
		\forall x \in Z_8,\quad x + a = x.
		\]
		
		Элемент $b$ задан как \textbf{мультипликативная единица}:
		\[
		\forall x \in Z_8,\quad x \cdot b = x.
		\]
		
		Также выполняется свойство поглощения:
		\[
		\forall x \in Z_8,\quad x \cdot a = a.
		\]
		
		В этой алгебре выполняются следующие свойства: коммутативность, ассоциативность и дистрибутивность.
		
		Эти свойства позволяют рассматривать структуру $\langle Z_8; +, \cdot \rangle$ как \textbf{коммутативное кольцо с единицей}.
		
		\subsection{Изоморфизм с кольцом вычетов $\mathbb{Z}/8\mathbb{Z}$}
		
		Введём биекцию $\varphi: Z_8 \to \{0,1,\dots,7\}$, сопоставляющую каждому элементу его порядковый номер в последовательности, порождённой многократным применением правила «+1» к элементу~$a$:
		\[
		\begin{aligned}
			\varphi(a) &= 0, &
			\varphi(b) &= 1, &
			\varphi(d) &= 2, &
			\varphi(h) &= 3, \\
			\varphi(c) &= 4, &
			\varphi(e) &= 5, &
			\varphi(g) &= 6, &
			\varphi(f) &= 7.
		\end{aligned}
		\]
		
		Отображение~$\varphi$ является изоморфизмом для исходной структуры.
		
		Данное отображение позволяет переводить результаты арифметических операций на числах в восьмеричной системе счисления в исходную структуру (a, b, c...).
		
		\subsection{«Большая» конечная арифметика}
		
		На основе «малой» арифметики строится позиционная система счисления по основанию~8, в которой:
		\item \textbf{Цифрами} являются элементы множества~$Z_8$,
		\item \textbf{Числа} записываются как строки длиной до 8~символов (например, $bbb$, $ccc$),
		\item Значение числа $X = x_{n-1} x_{n-2} \dots x_0$ определяется как
		\[
		X = \sum_{k=0}^{n-1} \varphi(x_k) \cdot 8^k.\qquad (1)
		\]
		
		Арифметические операции над многоразрядными числами реализуются следующим образом:
		\begin{enumerate}
			\item Преобразование операндов в целые числа по формуле (1).
			\item Выполнение операции в кольце целых чисел.
			\item Преобразование результата обратно в символьную форму с помощью последовательного деления на 8 и применения~$\varphi^{-1}$ к остаткам.
		\end{enumerate}
		
		
		При вычитании из меньшего большего совершается проход по кольцу от наименьшего числа к наибольшему: например, $a - b = ffffffff$.
		
		При нецелом частном ответ записывается в формате ''<целая часть>.<остаток>''.
		
		Такой подход обеспечивает корректную реализацию всех четырёх арифметических операций ($+, -, \cdot, \div$) в рамках заданной конечной структуры.
		
		
		
		\newpage
		\section{Особенности реализации}
		Программа состоит из двух классов: \code{Multiset} и \code{Interface}.
		
		Класс \code{Multiset} содержит в себе поля для хранения данных о мультимножестве и методы для проведения операций над мультимножествами. Мультимножества хранятся в контейнере \code{std::string}, т.к. с ним удобно работать.
		
		Класс \code{Interface} содержит в себе поля для хранения данных о всех мультимножествах в контейнере \code{std::map<std::string, Multiset>}, где ключи - названия мультимножеств, а значения - сами мультимножества. Методы класса отвечают за консольное меню (пользовательский ввод, вывод мультимножеств и результатов операций над ними).
		
		
		\subsection{Класс \protect\code{Multiset}}
		
		\begin{itemize}
			\item \textbf{Метод \code{generateGrayCode}}  
			\textbf{\\Вход:} \code{int n} - разрядность кода Грея.\\
			\textbf{Выход:} \code{std::vector<std::string> gray} - контейнер с кодами Грея.\\
			\textbf{Назначение:} генерирует коды Грея разрядности $n$.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				if (n <= 0) return {};
				std::vector<std::string> gray;
				int total = 1 << n;
				
				for (int i = 0; i < total; ++i) {
					int grayCode = i ^ (i >> 1);
					std::string code = "";
					for (int j = n - 1; j >= 0; --j) {
						code += (grayCode & (1 << j)) ? '1' : '0';
					}
					gray.push_back(code);
				}
				return gray;
			\end{lstlisting}
			
			\item \textbf{Метод \code{createUniverse}}  
			\textbf{\\Вход:} \code{int depth} - разрядность кода Грея, который будет храниться в универсуме.\\
			\textbf{Выход:} \code{std::vector<std::string> universe} - универсум по кодам Грея с заданной разрядностью.\\
			\textbf{Назначение:} создаёт универсум по кодам Грея.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				void Multiset::createUniverse(int depth) {
					universe = generateGrayCode(depth);
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{setMaxMultiplicity}}  
			\textbf{\\Вход:} \code{int limit} - значение максимальной кратности элементов.\\
			\textbf{Выход:} \code{int limit} - значение максимальной кратности элементов.\\
			\textbf{Назначение:} устанавливает максимальную кратность в универсуме (хранится в виде статической переменной).\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				void Multiset::setMaxMultiplicity(int limit) {
					maxMultiplicity = limit;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{getMaxMultiplicity}}  
			\textbf{\\Вход:} \code{int maxMultiplicity} - значение максимальной кратности элементов.\\
			\textbf{Выход:} \code{int maxMultiplicity} - значение максимальной кратности элементов.\\
			\textbf{Назначение:} возвращает текущую максимальную кратность.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				int Multiset::getMaxMultiplicity() {
					return maxMultiplicity;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{size}}  
			\textbf{\\Вход:} \code{Multiset input} - мультимножество.\\
			\textbf{Выход:} \code{int total} - мощность мультимножества.\\
			\textbf{Назначение:} возвращает мощность мультимножества.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				int Multiset::size() const {
					int total = 0;
					for (const auto& p : elements) total += p.second;
					return total;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{fillManual}}  
			\textbf{\\Вход:} \code{int size} - мощность создаваемого мультимножества.\\
			\textbf{Выход:} \code{Multiset multi} - мультимножество.\\
			\textbf{Назначение:} воздание и ручное заполнение мультимножества.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				void Multiset::fillManual(int size) {
					std::cin.ignore();
					if (size < 0) return;
					
					if (size != 0)
					std::cout << "Enter " << size << " Gray codes (limit: " << maxMultiplicity << ")\n"
					<< "(You can enter either Gray code only or Gray code [space] count; other numbers won't be accounted)" << std::endl;
					
					for (int i = 0; i < size; ) {
						std::string code;
						while (true) {
							std::cout << "Code #" << (i + 1) << ": ";
							
							std::string line;
							std::getline(std::cin, line);
							std::istringstream iss(line);
							
							std::string code;
							if (!(iss >> code)) {
								std::cout << "Empty input. Try again.\n";
								continue;
							}
							
							int count = 1;
							iss >> count;
							
							if (!isValidCode(code)) {
								std::cout << "Invalid code. Valid: ";
								for (const auto& c : universe) std::cout << c << " ";
								std::cout << "\nTry again.\n";
								continue;
							}
							
							if (!canAdd(code)) {
								std::cout << "You've reached your limit(" << maxMultiplicity 
								<< ") for the code \"" << code << "\". Please pick different.\n";
								continue;
							}
							
							int currentCount = frequency(code);
							if (currentCount + count > maxMultiplicity) {
								std::cout << "Adding " << count << " of \"" << code
								<< "\" would exceed limit (" << maxMultiplicity
								<< "). Currently have " << currentCount << ".\n"
								<< "Try again with fewer or different code.\n";
								continue;
							}
							
							for (int j = 0; j < count; ++j) {
								add(code);
							}
							
							i += count;
							break;
						}
					}
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{fillRandom}}  
			\textbf{\\Вход:} \code{int size} - мощность создаваемого мультимножества.\\
			\textbf{Выход:} \code{Multiset multi} - мультимножество.\\
			\textbf{Назначение:} создание и заполнение мультимножества случайными элементами.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				void Multiset::fillRandom(int size) {
					if (size <= 0 || universe.empty()) return;
					
					for (int i = 0; i < size; ++i) {
						std::string code;
						do {
							code = universe[rand() % universe.size()];
						} while (!canAdd(code));
						
						add(code);
					}
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{frequency}}  
			\textbf{\\Вход:} \code{const std::string\& code} - код Грея.\\
			\textbf{Выход:} \code{int count} - кратность элемента в мультимножестве.\\
			\textbf{Назначение:} возвращает кратность элемента (кода Грея) в мультимножестве.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				int Multiset::frequency(const std::string& code) const {
					auto it = elements.find(code);
					return (it != elements.end()) ? it->second : 0;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{canAdd}}  
			\textbf{\\Вход:} \code{const std::string\& code} - код Грея.\\
			\textbf{Выход:} \code{bool canAdd} - возможность добавления элемента в мультимножество.\\
			\textbf{Назначение:} проверяет, можно ли добавить элемент (код Грея) в мультимножество.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				bool Multiset::canAdd(const std::string& code) const {
					// Check if code is valid and if adding one more would exceed maxMultiplicity
					if (!isValidCode(code)) return false;
					int current = frequency(code);
					return current < maxMultiplicity;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{isValidCode}}  
			\textbf{\\Вход:} \code{const std::string\& code} - код Грея.\\
			\textbf{Выход:} \code{bool isValidCode} - корректность данного кода Грея (есть ли он в универсуме).\\
			\textbf{Назначение:} проверяет корректность данного кода Грея (принадлежит ли код универcуму).\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				bool Multiset::isValidCode(const std::string& code) const {
					for (const auto& u : universe) {
						if (code == u) return true;
					}
					return false;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{add}}  
			\textbf{\\Вход:} \code{const std::string\& code, int count = 1} - код Грея, который нужно добавить, и его кратность (по умолч. 1).\\
			\textbf{Выход:} \code{int added} - кол-во реально добавленных элементов.\\
			\textbf{Назначение:} добавляет элементы в массив.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				int Multiset::add(const std::string& code, int count = 1) {
					if (!isValidCode(code) || count <= 0) return 0;
					
					int current = frequency(code);
					int available = maxMultiplicity - current;
					int actualToAdd = std::min(count, available);
					
					if (actualToAdd > 0) {
						elements[code] += actualToAdd;
					}
					
					return actualToAdd;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{unionWith}}  
			\textbf{\\Вход:} \code{Multiset other} - мультимножество, с которым нужно провести операцию объединения.\\
			\textbf{Выход:} \code{Multiset result} - мультимножество, результат выполнения операции.\\
			\textbf{Назначение:} выполнение операции объединения над двумя мультимножествами.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				Multiset Multiset::unionWith(const Multiset& other) const {
					Multiset result;
					
					for (const auto& p : elements) {
						if (p.second > 0) {
							result.elements[p.first] = p.second;
						}
					}
					for (const auto& p : other.elements) {
						if (p.second > 0) {
							result.elements[p.first] = std::max(result.elements[p.first], p.second);
						}
					}
					return result;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{intersectionWith}}  
			\textbf{\\Вход:} \code{Multiset other} - мультимножество, с которым нужно провести операцию пересечения.\\
			\textbf{Выход:} \code{Multiset result} - мультимножество, результат выполнения операции.\\
			\textbf{Назначение:} выполнение операции пересечения над двумя мультимножествами.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				Multiset Multiset::intersectionWith(const Multiset& other) const {
					Multiset result;
					
					for (const auto& p : elements) {
						if (other.elements.count(p.first)) {
							result.elements[p.first] = std::min(p.second, other.elements.at(p.first));
						}
					}
					return result;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{differenceWith}}  
			\textbf{\\Вход:} \code{Multiset other} - мультимножество, с которым нужно провести операцию разности.\\
			\textbf{Выход:} \code{Multiset result} - мультимножество, результат выполнения операции.\\
			\textbf{Назначение:} выполнение операции разности над двумя мультимножествами.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				Multiset Multiset::differenceWith(const Multiset& other) const {
					return intersectionWith(other.complement());
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{symmetricDifferenceWith}}  
			\textbf{\\Вход:} \code{Multiset other} - мультимножество, с которым нужно провести операцию симметрической разности.\\
			\textbf{Выход:} \code{Multiset result} - мультимножество, результат выполнения операции.\\
			\textbf{Назначение:} выполнение операции симметрической разности над двумя мультимножествами.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				Multiset Multiset::symmetricDifferenceWith(const Multiset& other) const {
					Multiset result;
					auto uni = unionWith(other);
					auto inter = intersectionWith(other);
					result = uni.differenceWith(inter);
					
					return result;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{arithmeticSum}}  
			\textbf{\\Вход:} \code{Multiset other} - мультимножество, с которым нужно провести операцию арифметической суммы.\\
			\textbf{Выход:} \code{Multiset result} - мультимножество, результат выполнения операции.\\
			\textbf{Назначение:} выполнение операции арифметической суммы над двумя мультимножествами.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				Multiset Multiset::arithmeticSum(const Multiset& other) const {
					Multiset result;
					
					for (const auto& p : elements) result.elements[p.first] += p.second;
					for (const auto& p : other.elements) result.elements[p.first] += p.second;
					for (auto& p : result.elements)
					if (p.second > maxMultiplicity)
					p.second = maxMultiplicity;
					
					return result;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{arithmeticDifferenceWith}}
			\textbf{\\Вход:} \code{Multiset other} - мультимножество, с которым нужно провести операцию арифметической разности.\\
			\textbf{Выход:} \code{Multiset result} - мультимножество, результат выполнения операции.\\
			\textbf{Назначение:} выполнение операции арифметической разности над двумя мультимножествами.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				Multiset Multiset::arithmeticDifferenceWith(const Multiset& other) const {
					Multiset result;
					
					for (const auto& p : elements) {
						int count = p.second;
						if (other.elements.count(p.first)) {
							count -= other.elements.at(p.first);
						}
						if (count > 0) {
							result.elements[p.first] = count;
						}
					}
					return result;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{arithmeticProduct}}  
			\textbf{\\Вход:} \code{Multiset other} - мультимножество, с которым нужно провести операцию арифметического произведения.\\
			\textbf{Выход:} \code{Multiset result} - мультимножество, результат выполнения операции.\\
			\textbf{Назначение:} выполнение операции арифметического произведения над двумя мультимножествами.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				Multiset Multiset::arithmeticProduct(const Multiset& other) const {
					Multiset result;
					
					for (const auto& p : elements) {
						if (other.elements.count(p.first)) {
							result.elements[p.first] = std::min(p.second * other.elements.at(p.first), maxMultiplicity);
						}
					}
					
					return result;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{arithmeticDivision}}  
			\textbf{\\Вход:} \code{Multiset other} - мультимножество, с которым нужно провести операцию арифметического деления.\\
			\textbf{Выход:} \code{Multiset result} - мультимножество, результат выполнения операции.\\
			\textbf{Назначение:} выполнение операции арифметического деления над двумя мультимножествами.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				Multiset Multiset::arithmeticDivision(const Multiset& other) const {
					Multiset result;
					
					for (const auto& p : elements)
					if (other.elements.count(p.first) && other.elements.at(p.first) > 0)
					if (p.second / other.elements.at(p.first) > 0)
					result.elements[p.first] = p.second / other.elements.at(p.first);
					
					return result;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{complement}}  
			\textbf{\\Вход:} \code{Multiset current} - текущее мультимножество.\\
			\textbf{Выход:} \code{Multiset result} - новое мультимножество, являющееся дополнением текущего.\\
			\textbf{Назначение:} дополнение относительно максимальной кратности.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				Multiset Multiset::complement() const {
					Multiset result;
					
					for (const auto& code : universe) {
						int current = frequency(code);
						int needed = maxMultiplicity - current;
						if (needed > 0) {
							result.elements[code] = needed;
						}
					}
					
					return result;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{print}}  
			\textbf{\\Вход:}  \code{Multiset multi} - текущее мультимножество.\\
			\textbf{Выход:} \code{Multiset multi} - текущее мультимножество.\\
			\textbf{Назначение:} печатают мультимножество или универсум.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				void Multiset::print() const {
					std::cout << "{ ";
						bool first = true;
						for (const auto& p : elements) {
							if (!first) std::cout << ", ";
							std::cout << "\"" << p.first << "\"^" << p.second;
							first = false;
						}
						std::cout << "}" << std::endl;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{printU}}
			\textbf{\\Вход:} \code{std::vector<std::string> universe} - универсум.\\
			\textbf{Выход:} \code{std::vector<std::string> universe} - универсум.\\
			\textbf{Назначение:} печатает универсум.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				void Multiset::printU() const {
					std::cout << "{ ";
						bool first = true;
						for (const auto& p : universe) {
							if (!first) std::cout << ", ";
							std::cout << "\"" << p << "\"^" << 10;
							first = false;
						}
						std::cout << "}" << std::endl;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{getUniverse}}  
			\textbf{\\Вход:} \code{std::vector<std::string> universe} - универсум.\\
			\textbf{Выход:} \code{Multiset multiUni} универсум, представленный в виде типа \code{Multiset}.\\
			\textbf{Назначение:} возвращает универсум в виде типа \code{Multiset}.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				Multiset Multiset::getUniverse() {
					Multiset uni;
					for (const auto& elem : universe) {
						uni.elements[elem] = maxMultiplicity;
					}
					return uni;
				}
			\end{lstlisting}
		\end{itemize}
		
		\subsection{Класс \protect\code{Interface}}
		
		\begin{itemize}
			\item \textbf{Метод \code{isValidName}}  
			\textbf{\\Вход:} \code{const std::string\& name} - имя нового мультимножества.\\
			\textbf{Выход:} \code{bool correct} - валидно ли имя мультимножества.\\
			\textbf{Назначение:} проверяет, валидно ли имя мультимножества.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				bool Interface::isValidName(const std::string& name) {
					bool isValid = data_.find(name) == data_.end() && name != "";
					if (isValid)
					return true;
					else
					std::cout << "Multiset with this name already exists or name is invalid.\n"
					<< "Please, try again: ";
					return false;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{createMultisets}}  
			\textbf{\\Вход:} \code{bool rand} - режим создания мультимножества (ручное или случайное).\\
			\textbf{Выход:} \code{Multiset multi} - новое мультимножество.\\
			\textbf{Назначение:} создаёт новое мультимножество ручным или случайным способом; если нет универсума, сначала создает его.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				void Interface::createMultisets(bool rand) {
					if (data_.size() == 0) { // Here we set the universe parameters
						std::cout << "Enter bit depth: ";
						int depth;
						while (!(std::cin >> depth) || depth < 0) {
							std::cout << "Invalid input. Enter non-negative integer: ";
							IGN
						}
						
						bitDepth_ = depth;
						
						if (bitDepth_ == 0)
						goto AddUniverse;
						
						Multiset::createUniverse(depth);
						
						std::cout << "Enter universum multiplicity: ";
						int multi;
						IGN
						while (!(std::cin >> multi) || multi < 0) {
							std::cout << "Invalid input. Enter non-negative integer: ";
							IGN
						}
						Multiset::setMaxMultiplicity(multi);
						uniMultiplicity_ = multi;
						
						AddUniverse:
						if (uniMultiplicity_ == 0)
						Multiset::createUniverse(0);
						data_["U"] = Multiset::getUniverse();
						uniSize_ = Multiset::getUniverse().size();
					}
					
					if (rand) {
						createRandom();
					}
					else {
						Multiset A;
						
						std::cout << "Enter name of the multiset: ";
						std::string name;
						std::cin >> name;
						while (!isValidName(name)) {
							IGN
							std::cin >> name;
						}
						if (bitDepth_ * uniMultiplicity_ == 0) {
							goto AddMultiset;
						}
						std::cout << "\nHow to fill multiset?\n1. Manual\n2. Auto\n> ";
						int choice;
						IGN
						while (!(std::cin >> choice) || (choice != 1 && choice != 2)) {
							IGN
							std::cout << "Enter 1 or 2: ";
						}
						
						int sizeA;
						std::cout << "Enter size of the multiset " << name << ": ";
						IGN
						while (!(std::cin >> sizeA) || sizeA < 0 || sizeA > uniSize_) {
							IGN
							std::cout << "Size can't be negative or more than universe's size: ";
						}
						
						if (choice == 1) {
							std::cout << "Fill Multiset " << name << ':' << std::endl;
							A.fillManual(sizeA);
						}
						else {
							A.fillRandom(sizeA);
						}
						AddMultiset:
						data_[name] = A;
					}
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{displayMenu}}  
			\textbf{\\Вход:} \code{std::string} - текст, который нужно вывести в пользовательском меню.\\
			\textbf{Выход:} \code{std::string} - текст, который нужно вывести в пользовательском меню.\\
			\textbf{Назначение:} выводит меню программы.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				void Interface::displayMenu() {
					std::cout << "Choose an option:\n"
					<< "1. Create new multisets\n"
					<< "2. Perform an operation on existing multisets\n"
					<< "3. Print a multiset\n"
					<< "4. Print all multisets' names\n"
					<< "5. Print all multisets\n"
					<< "6. Create a random multiset\n"
					<< "7. Delete a multiset\n"
					<< "8. Reset (delete all multisets and universe)\n"
					<< "0. Exit\n> ";
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{performAll}}  
			\textbf{\\Вход:} \code{Multiset multi1, multi2; std::string nameA, nameB} - мультимножества и их имена.\\
			\textbf{Выход:} \code{Multiset} - результат выполнения операций над мультимножествами.\\
			\textbf{Назначение:} выполняет все операции и выводит результаты.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				void Interface::performAll(Multiset& A, Multiset& B, std::string& nameA, std::string& nameB) {
					std::cout << "\n======= MULTISETS =======\n";
					std::cout << "U: "; A.printU(); std::cout << '\n';
					std::cout << nameA << ": "; A.print(); std::cout << '\n';
					std::cout << nameB << ": "; B.print(); std::cout << '\n';
					std::cout << "\n======= OPERATIONS =======\n";
					std::cout << nameA << " union " << nameB << ": "; A.unionWith(B).print(); std::cout << '\n';
					std::cout << nameA << " inter " << nameB << ": "; A.intersectionWith(B).print(); std::cout << '\n';
					std::cout << nameA << " \\ " << nameB << ": "; A.differenceWith(B).print(); std::cout << '\n';
					std::cout << nameB << " \\ " << nameA << ": "; B.differenceWith(A).print(); std::cout << '\n';
					std::cout << nameA << " /\\ " << nameB << ": "; A.symmetricDifferenceWith(B).print(); std::cout << '\n';
					std::cout << nameA << " + " << nameB << ": "; A.arithmeticSum(B).print(); std::cout << '\n';
					std::cout << nameA << " - " << nameB << ": "; A.arithmeticDifferenceWith(B).print(); std::cout << '\n';
					std::cout << nameB << " - " << nameA << ": "; B.arithmeticDifferenceWith(A).print(); std::cout << '\n';
					std::cout << nameA << " * " << nameB << ": "; A.arithmeticProduct(B).print(); std::cout << '\n';
					std::cout << nameA << " / " << nameB << ": "; A.arithmeticDivision(B).print(); std::cout << '\n';
					std::cout << nameB << " / " << nameA << ": "; B.arithmeticDivision(A).print(); std::cout << '\n';
					std::cout << "Complement of " << nameA << ": "; auto compA = A.complement(); compA.print(); std::cout << '\n';
					std::cout << "Complement of " << nameB << ": "; auto compB = B.complement(); compB.print(); std::cout << '\n';
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{perform}}  
			\textbf{\\Вход:} \code{std::string nameA, nameB} - имена мультимножеств.\\
			\textbf{Выход:} \code{Multiset} - результат выполнения операций над мультимножествами.\\
			\textbf{Назначение:} позволяет выполнять выбранную операцию.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				void Interface::perform(std::string& nameA, std::string& nameB) {
					std::cout << "Enter the name of the 1st multiset: ";
					std::cin >> nameA;
					while (isValidName(nameA)) {
						std::cout << "Multiset with this name doesn't exist. Please, try again: ";
						std::cin >> nameA;
					}
					std::cout << "Enter the name of the 2nd multiset: ";
					std::cin >> nameB;
					while (isValidName(nameB)) {
						std::cout << "Multiset with this name doesn't exist. Please, try again: ";
						std::cin >> nameB;
					}
					
					Multiset compA;
					Multiset compB;
					int trash;
					int choice;
					
					while (true) {
						CL;
						std::cout << "Choose an operation:\n"
						<< "1. '" << nameA << "' union '" << nameB << "'\n"
						<< "2. '" << nameB << "' inter '" << nameB << "'\n"
						<< "3. '" << nameA << "' \\ '" << nameB << "'\n"
						<< "4. '" << nameB << "' \\ '" << nameA << "'\n"
						<< "5. '" << nameA << "' /\\ '" << nameB << "'\n"
						<< "6. '" << nameA << "' + '" << nameB << "'\n"
						<< "7. '" << nameA << "' - '" << nameB << "'\n"
						<< "8. '" << nameA << "' * '" << nameB << "'\n"
						<< "9. '" << nameA << "' / '" << nameB << "'\n"
						<< "0. '" << nameB << "' / '" << nameA << "'\n"
						<< "d. Do all operations\n"
						<< "a. Complement of '" << nameA << "'\n"
						<< "b. Complement of '" << nameB << "'\n"
						<< "q. Go to main menu\n>";
						
						choice = _getch();
						
						switch (choice) {
							case '1':
							std::cout << "A union B: "; data_[nameA].unionWith(data_[nameB]).print(); std::cout << '\n';
							W;
							break;
							case '2':
							std::cout << "A inter B: "; data_[nameA].intersectionWith(data_[nameB]).print(); std::cout << '\n';
							W;
							break;
							case '3':
							std::cout << "A \\ B: "; data_[nameA].arithmeticDifferenceWith(data_[nameB]).print(); std::cout << '\n';
							W;
							break;
							case '4':
							std::cout << "B \\ A: "; data_[nameB].arithmeticDifferenceWith(data_[nameA]).print(); std::cout << '\n'; 
							W;
							break;
							case '5':
							std::cout << "A sym \\ B: "; data_[nameA].symmetricDifferenceWith(data_[nameB]).print(); std::cout << '\n';
							W;
							break;
							case '6':
							std::cout << "A + B: "; data_[nameA].arithmeticSum(data_[nameB]).print(); std::cout << '\n';
							W;
							break;
							case '7':
							std::cout << "A - B: "; data_[nameA].differenceWith(data_[nameB]).print(); std::cout << '\n';
							W;
							break;
							case '8':
							std::cout << "A * B: "; data_[nameA].arithmeticProduct(data_[nameB]).print(); std::cout << '\n';
							W;
							break;
							case '9':
							std::cout << "A / B: "; data_[nameA].arithmeticDivision(data_[nameB]).print(); std::cout << '\n';
							W;
							break;
							case '0':
							std::cout << "B / A: "; data_[nameB].arithmeticDivision(data_[nameA]).print(); std::cout << '\n';
							W;
							break;
							case 'd':
							performAll(data_[nameA], data_[nameB], nameA, nameB);
							W;
							break;
							case 'a':
							std::cout << "Complement of A: "; compA = data_[nameA].complement(); compA.print(); std::cout << '\n';
							W;
							break;
							case 'b':
							std::cout << "Complement of B: "; compB = data_[nameB].complement(); compB.print(); std::cout << '\n';
							W;
							break;
							case 'q':
							goto Break;
							default:
							std::cout << "Invalid option. Please, try again!\n";
							W;
						}
						continue;
						Break:
						break;
					}
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{printMultiset}}  
			\textbf{\\Вход:} \code{std::string name} - имя мультимножества.\\
			\textbf{Выход:} \code{Multiset multi} - мультимножество.\\
			\textbf{Назначение:} выводит содержимое множества.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				void Interface::printMultiset(std::string& name) {
					data_[name].print();
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{printNames}}  
			\textbf{\\Вход:} \code{std::string} - имена мультимножеств.\\
			\textbf{Выход:} \code{std::string} - имена мультимножеств.\\
			\textbf{Назначение:} выводит список имён всех множеств.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				void Interface::printNames() {
					int i = 1;
					for (const auto& pair : data_) {
						std::cout << "#" << i << ": " << pair.first << std::endl;
						i++;
					}
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{printAllMultisets}}  
			\textbf{\\Вход:} \code{Multiset} - все созданные мультимножества.\\
			\textbf{Выход:} \code{Multiset} - все созданные мультимножества.\\
			\textbf{Назначение:} печатает все мультимножества.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				void Interface::printAllMultisets() {
					int i = 1;
					for (const auto& pair : data_) {
						std::cout << '#' << i << " \"" << pair.first << "\": ";
						pair.second.print();
						i++;
					}
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{createRandom}}  
			\textbf{\\Вход:} \code{Multiset universe} - универсум, на основе которого будет создаваться мультимножество.\\
			\textbf{Выход:} \code{Multiset multi} - мультимножество.\\
			\textbf{Назначение:} создаёт случайное мультимножество.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
				void Interface::createRandom() {
					std::string name;
					int i = 10000;
					do { name = std::to_string(rand() % i++); } while (!isValidName(name));
					Multiset A;
					i = 100;
					int size = rand() % i;
					while (size > uniMultiplicity_ * bitDepth_)
					size--;
					A.fillRandom(size);
					data_[name] = A;
					std::cout << "Random multiset created.\n"
					<< "Name: " << name
					<< "\nSize: " << A.size() << std::endl;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{deleteMultiset()}}  
			\textbf{\\Вход:} \code{std::string name} - имя удаляемого мультимножества.\\
			\textbf{Выход:} \code{std::map<std::string, Multiset> data} - контейнер мультимножеств (обновленный: удалено выбранное мультимножество).\\
			\textbf{Назначение:} удаляет мультимножество.\\
			\textbf{Листинг:}
			\begin{lstlisting}[language=C++]
				void Interface::deleteMultiset() {
					std::string name;
					std::cout << "Enter the name of the multiset to delete: ";
					std::cin >> name;
					while (isValidName(name) || name == "U") { // Checks if it DOESN'T exist yet.
						if (isValidName(name))
						std::cout << "Multiset with this name doesn't exist. Please, try again: ";
						else
						std::cout << "Can't delete universe. Please, try again: ";
						std::cin >> name;
					}
					data_.erase(name);
					std::cout << "Deleted." << std::endl;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{reset}}  
			\textbf{\\Вход:} \code{std::map<std::string, Multiset> data} - контейнер  мультимножеств.\\
			\textbf{Выход:} \code{std::map<std::string, Multiset> data} - пустой контейнер мультимножеств.\\
			\textbf{Назначение:} удаляет все мультимножества.\\
			\textbf{Листинг:}
			\begin{lstlisting}[language=C++]
				void Interface::reset() {
					data_.clear();
					bitDepth_ = 0;
					uniMultiplicity_ = 0;
				}
			\end{lstlisting}
			
			\item \textbf{Метод \code{run}}  
			\textbf{\\Вход:} \code{std::iostream} - поля ввода и вывода программы.\\
			\textbf{Выход:} \code{int} - статус завершения работы программы.\\
			\textbf{Назначение:} запускает основной цикл программы.\\
			\textbf{Листинг:}
			\begin{lstlisting}[language=C++]
				int Interface::run() {
					int trash;
					std::string nameA;
					std::string nameB;
					
					std::cout << "Hello!\n"
					<< "Here you can create multisets and perform operations upon them.\n"
					<< "Press any key to continue.";
					trash = _getch();
					
					while (true) {
						CL;
						displayMenu();
						Again:
						char option = _getch();
						switch (option) {
							case '1':
							CL;
							createMultisets();
							std::cout << "Press any key to continue.";
							trash = _getch();
							break;
							
							case '2':
							CL;
							if (data_.size() < 2) {
								std::cout << "You need at least two multisets to perform operations.\n"
								<< "Press any key to continue.";
								trash = _getch();
								break;
							}
							perform(nameA, nameB);
							break;
							
							case '3':
							CL;
							if (data_.size() == 0) {
								std::cout << "Nothing to print. No multisets available." << std::endl;
								W;
								break;
							}
							std::cout << "Enter the name of a multiset to print: ";
							std::cin >> nameA;
							while (isValidName(nameA)) { // Checks if it DOESN'T exist yet.
								std::cout << "Wrong name. Please try again: ";
								std::cin >> nameA;
							}
							printMultiset(nameA);
							W;
							break;
							
							case '4':
							CL;
							if (data_.size() == 0) {
								std::cout << "Nothing to print. No multisets available." << std::endl;
								W;
								break;
							}
							printNames();
							W;
							break;
							
							case '5':
							CL;
							if (data_.size() == 0) {
								std::cout << "Nothing to print. No multisets available." << std::endl;
								W;
								break;
							}
							printAllMultisets();
							W;
							break;
							
							case '6':
							CL;
							if (data_.size() == 0)
							createMultisets(true);
							else
							createRandom();
							W;
							break;
							
							case '7':
							CL;
							if (data_.size() == 0) {
								std::cout << "Nothing to delete. No multisets available." << std::endl;
								W;
								break;
							}
							deleteMultiset();
							W;
							break;
							
							case '8':
							CL;
							reset();
							std::cout << "Resetted." << std::endl;
							W;
							break;
							
							case '0':
							return 0;
							
							default:
							std::cout << "Invalid option. Please, try again!\n";
							goto Again;
						}
					}
				}
			\end{lstlisting}
		\end{itemize}
		
		%\subsection{Файл \protect\code{main.cpp}}
		
		%\begin{itemize}
		%	\item \textbf{Функция \code{main}}  
		%	\textbf{\\Вход:} отсутствует.\\
		%	\textbf{Выход:} \code{int}.\\
		%	\textbf{Назначение:} Точка входа в программу. Создаёт меню и запускает работу.\\
		%	\textbf{Листинг:}
		%	\begin{lstlisting}[language=C++]
			%		int main() {
				%			Interface menu;
				%			menu.run();
				%			return 0;
				%		}
			%	\end{lstlisting}
		\%end{itemize}
		
		
		\section{Результаты работы программы}
		
		Разработанная программа имеет консольный интерфейс и предоставляет пользователю меню, позволяющее поэтапно выполнять все действия. 
		
		\subsection*{Меню программы}
		
		После запуска программы отображается главное меню, через которое пользователь может:
		\begin{itemize}
			\item создать новое мультимножество (ручное или случайное заполнение);
			\item вывести список всех созданных мультимножеств;
			\item выбрать два мультимножества для выполнения операций;
			\item выполнить все операции сразу или выбрать отдельную операцию;
			\item выйти из программы.
		\end{itemize}
		
		\subsection*{Создание мультимножеств}
		
		Программа поддерживает два режима создания мультимножеств:
		\begin{itemize}
			\item \textbf{ручной режим}: пользователь вводит коды Грея и их кратности, программа проверяет корректность кода и не позволяет превысить максимальную кратность;
			\item \textbf{автоматический режим}: программа случайным образом заполняет мультимножество элементами универсума, не превышая заданные ограничения; пользователю необходимо ввести имя и мощность.
			
			Также для быстрого создания мультимножеств можно использовать создание случайного мультимножества: в таком случае у него будут случайные имя и содержимое, что особенно удобно для быстрой генерации.
		\end{itemize}
		
		\subsection*{Работа с несколькими мультимножествами}
		
		Программа может одновременно хранить много мультимножеств, каждому из которых присваивается уникальное имя.
		В любой момент пользователь может вывести названия и содержимое всех мультимножеств.
		Это особенно удобно, если пользователь забыл их названия: с помощью этого списка он сможет найти нужные ему мультимножества и провести над ними необходимые операции.
		
		\subsection*{Обработка некорректного ввода}
		
		Программа устойчиво ведёт себя при некорректных данных:
		\begin{itemize}
			\item При вводе неверных команд в меню отображается предупреждение и предлагается повторить ввод;
			\item при попытке ввести код, отсутствующий в универcуме, выводится сообщение об ошибке, а также список возможных кодов (сам универсум);
			\item при попытке превысить максимальную кратность программа блокирует добавление;
			\item при попытке обращения к несуществующему мультимножеству отображается предупреждение и предлагается повторить ввод;
			\item при попытке создать мультимножество с уже существующим именем программа предлагает повторить ввод и т.д.
		\end{itemize}
		
		\subsection*{Работа с пустыми множествами}
		
		Программа корректно обрабатывает пустые мультимножества:  
		все операции (объединение, пересечение, разность и др.) с пустыми мультимножествами дают ожидаемый математический результат, что демонстрирует устойчивость реализации.
		
		\subsection*{Пример работы}
		
		При запуске программы высвечивается приветственное окно. Чтобы продолжить в главное меню и начать пользоваться основным функционалом программы, надо нажать на любую кнопку (рис. \ref{hello}).	
		
		\begin{figure}[H]
			\centering
			%\includegraphics[width=0.9\textwidth]{hello.png}
			\caption[Приветственное сообщение]{Приветственное сообщение при запуске программы.}
			\label{hello}
		\end{figure}
		
		После этого пользователь попадает в главное меню, где ему предлагается ряд опций на выбор. Чтобы выбрать нужную опцию, пользователю нужно ввести соответствующую цифру (рис. \ref{fig:menu}).
		
		\begin{figure}[H]
			\centering
		%	\includegraphics[width=0.9\linewidth]{menu}
			\caption[Меню]{Меню программы.}
			\label{fig:menu}
		\end{figure}
		
		Если пользователь введет некорректный вариант, программа об этом сообщит и предложит выбрать снова (рис. \ref{fig:menuerr}).
		
		\begin{figure}[H]
			\centering
		%	\includegraphics[width=0.9\linewidth]{menuErr}
			\caption{Обработка некорретного пользовательского ввода.}
			\label{fig:menuerr}
		\end{figure}
		
		Если пользователь решит выполнить какие-то операции над мультимножествами, пока они не заданы, программа сообщит об этом и попросит сначала создать мультимножества (рис. \ref{fig:perferr}).
		
		\begin{figure}[H]
			\centering
		%	\includegraphics[width=0.9\linewidth]{perfErr}
			\caption{Обработка попытки проведения операций над несуществующими мультимножествами.}
			\label{fig:perferr}
		\end{figure}
		
		Процесс создания мультимножеств включает в себя несколько этапов (рис. \ref{fig:createauto}).
		\begin{enumerate}
			\item Ввод разрядности, если универсум еще не создан (например, 3).
			\item Ввод кратности элементов универсума, если он еще не создан (например, 5).
			\item Название мультимножества (например, A).
			\item Выбор заполнения мультимножества: ручной или автоматический.
			\item Ввод мощности мультимножества (например, 10).
		\end{enumerate}
		
		\begin{figure}[H]
			\centering
		%	\includegraphics[width=0.9\linewidth]{createAuto}
			\caption{Создание мультимножества с автоматическим заполнением.}
			\label{fig:createauto}
		\end{figure}
		
		При ручном наборе элементов мультимножества пользователь может вводить как указать кратность текущего элемента, так и опустить ее (в таком случае будет использовано значение кратности по умолчанию - 1). 
		Если такой элемент уже существует, кратности будут сложены. 
		Если в процессе создания мультимножества будут введены неверные данные (например, слишком большая кратность), программа сообщит об этом и попросит ввести корретные данные (рис. \ref{fig:createmanual}).
		
		\begin{figure}[H]
			\centering
		%	\includegraphics[width=0.9\linewidth]{createManual}
			\caption{Создание мультимножества с ручным вводом элементов.}
			\label{fig:createmanual}
		\end{figure}
		
		После того как пользователь создаст хотя бы одно мультимножество, он сможет использовать весь функционал программы, в том числе операции над ними, поскольку вместе с первым мультимножеством создается и универсум, который можно увидеть, например, при выборе опции 5 "Print all multisets" (рис. \ref{fig:printall}).
		
		\begin{figure}[H]
			\centering
		%	\includegraphics[width=0.9\linewidth]{printAll}
			\caption{Вывод всех мультимножеств.}
			\label{fig:printall}
		\end{figure}
		
		Для проведения операций над мультимножествами пользователю надо выбрать пункт 2 в меню (рис. \ref{fig:option2}).
		
		\begin{figure}[H]
			\centering
		%	\includegraphics[width=0.9\linewidth]{option2}
			\caption{Опция для проведения операций над мультимножествами.}
			\label{fig:option2}
		\end{figure}
		
		Далее ему будет предложено ввести названия мультимножеств, с которыми будут проводиться операции. При неверном названии будет предупреждение от программы и просьба ввести корректное название (рис. \ref{fig:enternames}).
		
		\begin{figure}[H]
			\centering
		%	\includegraphics[width=0.9\linewidth]{enterNames}
			\caption{Ввод названий мультимножеств для проведения операций.}
			\label{fig:enternames}
		\end{figure}
		
		После ввода названий мультимножеств пользователю предоставляется список возможных операций над ними. Чтобы выбрать операцию, пользователю нужно нажать на соответствующую клавишу. При неверном выборе программа попросит пользователя выбрать корректный вариант (рис. \ref{fig:operwrong}).
		
		\begin{figure}[H]
			\centering
		%	\includegraphics[width=0.9\linewidth]{operWrong}
			\caption{Неверный выбор операции над мультимножествами.}
			\label{fig:operwrong}
		\end{figure}
		
		Для удобства пользователю предоставляется вариант "Do all operations" ("Сделать все операции"). При выборе этого варианта пользователь получит результаты всех предложенных операций над этими мультимножествами (рис. \ref{fig:doall}).
		
		\begin{figure}[H]
			\centering
		%	\includegraphics[width=0.9\linewidth]{doAll}
			\caption{Выполнение всех операций над мультимножествами.}
			\label{fig:doall}
		\end{figure}
		
		Результаты подтвердили, что все операции над мультимножествами реализованы корректно.
		
		\newpage
		\section*{Заключение}
		\addcontentsline{toc}{section}{Заключение}
		
		В ходе лабораторной работы была разработана программа, позволяющая:
		\begin{itemize}
			\item генерировать бинарный код Грея заданной разрядности;
			\item формировать мультимножества двумя способами (ручной и автоматический);
			\item выполнять над мультимножествами различные операции:
			\begin{itemize}
				\item объединение,
				\item пересечение,
				\item разность,
				\item симметрическая разность,
				\item дополнение,
				\item арифметическая сумма,
				\item арифметическая разность,
				\item арифметическое произведение,
				\item арифметическое деление;
			\end{itemize}
			\item обеспечивать защиту от некорректного пользовательского ввода.
		\end{itemize}
		
		Программа демонстрирует корректную реализацию всех заданных функций. 
		Программа создана по принципам ООП: выделены отдельные классы \code{Multiset} и \code{Interface}, что удобно разделяет интерфейс и функционал каждого из класса и позволяет вносить изменения в программу легче, чем если бы она имела процедурную структуру.
		
		\paragraph{Плюсы программы.}
		\begin{itemize}
			\item Использование объектно-ориентированной парадигмы программирования, что позволяет удобно модифицировать программу.
			%\item Наличие всех основных операций над мультимножествами.
			%\item Возможность ручного и автоматического заполнения.
			\item Возможность работы над несколькими мультимножествами без стирания предыдущих из памяти.
			\item Возможность удаления мультимножеств.
		\end{itemize}
		
		\paragraph{Минусы программы.}
		\begin{itemize}
			%\item Отсутствие графического интерфейса.
			\item Все данные хранятся в оперативной памяти, без сохранения на диск.
			\item Ограничения по размеру входных данных (из-за возможного целочисленного переполнения при больших объемах).
			\item Использованиe контейнеров STL, что ухудшает производительность и повышает расходы памяти.
		\end{itemize}
		
		\paragraph{Масштабирование.}  
		Используемая архитектура позволяет легко добавлять новые операции над мультимножествами (например, вычисление мощности или сортировку по частоте).  
		Также возможна интеграция с графическим интерфейсом или веб-интерфейсом.  
		В будущем можно добавить возможность работы с тернарными операциями.
		
		В перспективе программа может быть:
		\begin{itemize}
			\item использована как часть библиотеки по дискретной математике;
			\item интегрирована в учебные курсы для демонстрации операций над мультимножествами;
			\item адаптирована под параллельные вычисления для одновременных операций над большими мультимножествами или для ускорения самих операций.
		\end{itemize}
		
		Таким образом, реализованная программа является масштабируемой и обладает потенциалом развития. Её структура позволяет расширять функциональность и использовать в более крупных программных системах.
		
		\newpage
		
		\begin{thebibliography}{99}
			\addcontentsline{toc}{section}{Список литературы}
			\bibitem{oop} Павловская Т. А., Щюпак Ю. А. С++ Объектно-ориентированное программирование: Практикум. — СПб.: Питер, 2006. — 265 с.
			\bibitem{gray} Коды Грэя и задачи перебора (Электронный ресурс).\\
			URL: \url{https://habr.com/ru/articles/200806/}\\
			(дата обращения: 13.09.2025).
			\bibitem{dismath} Секция "Телематика" (Электронный ресурс).\\
			URL: \url{https://tema.spbstu.ru/dismath/}\\
			(дата обращения: 13.09.2025).
			\bibitem{map} Класс map | Microsoft Learn (Электронный ресурс).\\
			URL: \url{https://learn.microsoft.com/ru-ru/cpp/standard-library/map-class?view=msvc-170}\\
			(дата обращения: 18.09.2025).
		\end{thebibliography}
		
		\newpage
		%\section*{Приложение}
		%\addcontentsline{toc}{section}{Приложение}
		
		\section*{Приложение 1. Файл Multiset.h.}
		\addcontentsline{toc}{section}{Приложение 1. Файл Multiset.h}
		%\lstinputlisting[language=C++,caption={Файл Multiset.h}]{Multiset.h}
		\newpage
		
		\section*{Приложение 2. Файл Multiset.cpp.}
		\addcontentsline{toc}{section}{Приложение 2. Файл Multiset.cpp}
		%\lstinputlisting[language=C++,caption={Файл Multiset.cpp}]{Multiset.cpp}
		\newpage
		
		\section*{Приложение 3. Файл Interface.h.}
		\addcontentsline{toc}{section}{Приложение 3. Файл Interface.h}
		%\lstinputlisting[language=C++,caption={Файл Interface.h}]{Interface.h}
		\newpage
		
		\section*{Приложение 4. Файл Interface.cpp.}
		\addcontentsline{toc}{section}{Приложение 4. Файл Interface.cpp}
		%\lstinputlisting[language=C++,caption={Файл Interface.cpp}]{Interface.cpp}
		\newpage
		
		\section*{Приложение 5. Файл main.cpp.}
		%\addcontentsline{toc}{section}{Приложение 5. Файл main.cpp}
	%	\lstinputlisting[language=C++,caption={Файл main.cpp}]{main.cpp}
		
	\end{document}
