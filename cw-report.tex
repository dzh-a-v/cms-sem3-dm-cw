%TODO
%
%
%
%
%
%
%
%
%
%
%
%

\documentclass[14pt]{extreport}
\usepackage{indentfirst}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\addto\captionsrussian{%
	\renewcommand{\contentsname}{Содержание}%
}
\addto\captionsrussian{%
	\renewcommand{\bibname}{Список литературы}%
}
\usepackage[top = 20mm, left = 30mm, right = 15mm, bottom = 20mm]{geometry}
\setlength\parindent{12.5mm}
\renewcommand{\baselinestretch}{1.5}
\def\hrf#1{\hbox to#1{\hrulefill}}
\usepackage{ragged2e}
\usepackage{caption}
\usepackage{multicol}
\usepackage{mathtools}
\usepackage{url}
\usepackage{xurl}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{courier}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{courier}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{float}

\renewcommand\thesection{\arabic{section}}

% Цвета для подсветки
\definecolor{bluekeywords}{rgb}{0.125,0.375,0.625}
\definecolor{greencomments}{rgb}{0.125,0.5,0.125}
\definecolor{redstrings}{rgb}{0.875,0.125,0.125}
\definecolor{graynumbers}{rgb}{0.5,0.5,0.5}
\definecolor{lightgray}{gray}{0.95}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

% Макрос для кода (Courier + серый фон)
%\usepackage{tgcursor}  % делает \texttt = TeX Gyre Cursor (аналог Courier)
\newcommand{\code}[1]{\colorbox{lightgray}{\texttt{#1}}}


\lstset{
	language=C++,
	basicstyle=\ttfamily\small,
	keywordstyle=\color{bluekeywords}\bfseries,
	commentstyle=\color{greencomments},
	stringstyle=\color{redstrings},
	numberstyle=\color{graynumbers},
	numbers=left,
	numbersep=10pt,
	columns=fullflexible,
	tabsize=4,
	showspaces=false,
	showstringspaces=false,
	breaklines=true,
	backgroundcolor=\color{lightgray},
	frame=single,
	rulecolor=\color{gray!30!black},
	captionpos=b
}


\begin{document}
	\sloppy
	\thispagestyle{empty}
	\centering{
		Министерство образования и науки Российской Федерации\\
		Федеральное государственное автономное образовательное учреждение высшего образования\\
		«Санкт-Петербургский политехнический университет Петра Великого»\\[10pt]
		Институт компьютерных наук и кибербезопасности\\
		Высшая школа технологий искусственного интеллекта\\
		02.03.01 Математика и компьютерные науки\\
		\vspace{\fill}
		{\large
			Отчёт по дисциплине\\
			{\Large \bf Дискретная математика\\Курсовая работа}\\
			{\Large <<Калькулятор конечной арифметики $Z_8$}>>}
			\vspace{\fill}
		}
		
		\flushright
		{
			{\bf Выполнил:}\\
			студент группы 5130201/40003\\
			Джабраилов А.В.\\
			{\bf Принял:}\\
			Востров А.В.\\
			<<\hrf{2em}>> \hrf{6em} 2025~г.
		}
		
		\centering{
			Санкт-Петербург, 2025
		}
		
		\newpage
		\justifying
		\tableofcontents
		
		\newpage
		\section*{Введение}
		\addcontentsline{toc}{section}{Введение}
		\subsection*{Актуальность и цель работы}
		%\addcontentsline{toc}{subsection}{Актуальность и цель работы}
		Использование кода Грея позволяет минимизировать количество ошибок при переходе от одного состояния к другому, что применяется, например, в кодировании данных.
		Мультимножества позволяют описывать системы, где элемент может встречаться несколько раз — это востребовано в базах данных, статистике и других областях.
		
		Таким образом, разработка программного инструмента, который демонстрирует генерацию кода Грея и операции над мультимножествами, способствует формированию навыков работы с дискретными структурами данных и алгоритмами, а также помогает на практике закрепить фундаментальные понятия теории множеств.
		
		
		\newpage
		\section{Постановка задачи}
		
		В рамках лабораторной работы необходимо реализовать калькулятор "большой" конечной арифметики $<Z_i;+,*>$ (8 разрядов) для четырех действий (+, -, *, /) на основе "малой" конечной арифметики, где задано правило «+1» и выполняются свойства коммутативности (+,*), ассоциативности (+, *), дистрибутивности * относительно +, заданы аддитивная единица «a» и мультипликативная единица «b», а также выполняется свойство: $(\forall x) х*a=a$. 
		
		Цель данной работы — реализовать программу, которая:
		\begin{itemize}
			\item поддерживает сложение для данной арифметики,
			\item поддерживает разность для данной арифметики,
			\item поддерживает умножение для данной арифметики,
			\item подддерживает деление для данной арифметики,
			\item поддерживает мультиразрядность (возможна операция bbb + ccc),
			\item поддерживает отрицательные числа,
			\item выполняет вычисления только в рамках данной арифметики без перевода в иные системы счисления.
		\end{itemize}
		
		\newpage
		
		
		\section{Математическое описание}
		
		\subsection{Конечная арифметика $Z_8$}
		
		Рассмотрим нашу конечную арифметику
		\[
		Z_8 = \{a, b, c, d, e, f, g, h\},
		\]
		в которой задана операция «+1», определяющая правило перехода от элемента к следующему:
		\[
		\begin{array}{c|cccccccc}
			x      & a & b & c & d & e & f & g & h \\ \hline
			x + 1  & b & d & e & h & g & a & f & c
		\end{array}
		\]
		
		Это правило задаёт циклическую аддитивную структуру порядка 8. Элемент $a$ является \textbf{аддитивной единицей}:
		\[
		\forall x \in Z_8,\quad x + a = x.
		\]
		
		Элемент $b$ задан как \textbf{мультипликативная единица}:
		\[
		\forall x \in Z_8,\quad x \cdot b = x.
		\]
		
		Выполняется свойство поглощения:
		\[
		\forall x \in Z_8,\quad x \cdot a = a.
		\]
		
		В этой алгебре выполняются следующие свойства: коммутативность, ассоциативность и дистрибутивность.
		
		Эти свойства позволяют рассматривать структуру $\langle Z_8; +, \cdot \rangle$ как \textbf{коммутативное кольцо с единицей}.
		
		\subsection{Арифметические операции}
		Для выполнения арифметических операций (+, -, *, /) была составлена следующая логика.
		
		\subsubsection{Сложение}
		Сложение выполняется по следующей логике.
		\begin{enumerate}[]
			\item Пусть надо сложить числа \code{A} и \code{B}.
			\item Выбирается наибольшее из этих двух чисел (можно, т.к. данная алгебра коммутативна). Пусть наибольшее в данном случае \code{A}.
			\item К \code{A} прибавляется элемент \code{b} (мультипликативная единица) \code{B} раз. Это, в свою очередь, производится по следующей логике.
			\begin{enumerate}[]
				\item Если разряд, к которому прибавлялось \code{b}, не был равен \code{f} до прибавления, измененным остается только текущий разряд.
				\item В противном случае, \code{b} прибавляется к следующему разряду (перенос), и так до тех пор, пока не надо будет совершать перенос.
			\end{enumerate}
		\end{enumerate}
		
		Выбор наибольшего из двух чисел во втором пункте обоснован оптимизацией вычислений, т.к. если мы складываем, например, \code{b} и \code{fffffffg}, намного быстрее прибавить один раз \code{b} к \code{fffffffg}, чем наоборот.
		
		\subsubsection{Умножение}
		Умножение выполняется по следующей логике.
		\begin{enumerate}[]
			\item Пусть надо умножить число \code{А} на \code{В}.
			\item Выбирается наибольшее из этих двух чисел (коммутативность). Пусть наибольшее в данном случае \code{А}.
			\item К \code{А} прибавляется \code{А} \code{В-1} раз, что реализовано через правило "+1".
		\end{enumerate}
		
		Выбор наибольшего из двух чисел во втором пункте обоснован оптимизацией вычислений, т.к. если мы умножем, например, \code{baa} и \code{baaa}, намного быстрее прибавлять к себе \code{baaa} \code{baa} раз, чем наоборот.
		
		\subsubsection{Вычитание}
		Вдобавок к таблице правила "+1" была создана аналогичная таблица правила "-1".
		
		Логика вычитания реализована так же, как и сложения, за исключением того, что мы "занимаем" разряд в случае, если вычитаемый разряд на момент вычитания равен \code{a}, что вызовет переход к \code{f}, далее операция производится для старшего разряда, и так до тех пор, пока занимать разряд не придется.
		
		\subsubsection{Деление}
		Деление реализовано так же, как умножение, за исключением того, что вместо сложения мы используем вычитание из числа \code{А} числа \code{В} до тех пор, пока промежуточный	 результат вычитания не будет меньше \code{А}; ответ равен текущему результату вычитания и остатку (последнему промежуточному результату).
		
		\subsubsection{Отрицательные числа и операции с ними}
		Операции с отрицательными числами основываются на операциях с положительными, всё заключается в изменении самой операции (например, сложение положительного и отрицательного чисел можно рассматривать как разность), а эти изменения опираются на свойства коммутативных колец (например, $-a + b = b + -a = b - a$).
		
		Операции с отрицательными числами проводятся по следующей логике:
		
		\textbf{Если отрицательно одно число:}
		\begin{enumerate}[]
			\item Пусть модуль отрицательного числа \code{А}, а положительное число \code{В}.
			\item При сложении вычитаем из модуля большего модуль меньшего; если \code{A} > \code{B}, приписываем минус в начале ответа, в противном случае нет.
			\item При вычитании складываем модули чисел.
			\item При умножении совершаем умножение и приписываеим минус.
			\item При делении:
			\begin{itemize}[]
				\item если остатка при делении нет, приписываем минус;
				\item если остаток при делении есть, увеличиваем модуль частного на 1 и вычитаем из делителя текущий остаток.
			\end{itemize}
		\end{enumerate}
		
		\textbf{Если оба числа отрицательны:}
		\begin{enumerate}[]
			\item Пусть модули двух отрицательных чисел \code{A} и \code{B} соответственно.
			\item При сложении складываем модули и приписываем минус.
			\item При вычитании берем модуль большего, вычитаем из него модуль меньшего; если \code{A} > \code{B}, приписываем минус, в противном случае нет.
			\item При умножении совершаем умножение модулей.
			\item При делении совершается деление модулей.
		\end{enumerate}
		
		\subsection{Ограничения}
		В данной алгебре присутствуют следующие ограничения:
		\begin{itemize}
			\item нельзя делить на ноль;
			\item нельзя проводить операции над числами, превышающими 8 разрядов;
			\item результат операции не должен превышать 8 разрядов.
		\end{itemize}
		
		Выход за эти ограничения ведет к неопределенному выходу, т.е. результат таких операций неизвестен.
		
		\newpage
		\section{Особенности реализации}
		%Программа состоит из двух классов: \code{Z8Number} и \code{OverflowError}.
		
		\subsection{Реализация алгебраической логики}
		
		Математическая логика программы реализована в классе \code{Z8Number}. Он содержит в себе поля для хранения данных о числе и функции для проведения операций над ними.
		
		%Класс \code{OverflowError} содержит в себе код ошибку, вызываемую при переполнении (ограничение на число в рамках данной структуры составляет 8 разрядов).
		
		В рамках данного описания числами будут называться элементы структуры $Z_8$ (\code{a}, \code{b}, ..., \code{f}).
		
		
		%\subsection{Класс \protect\code{Z8Number}}
		
		\begin{itemize}
			\item \textbf{Метод \code{getNeg}}  
			\textbf{\\Вход:} \code{bool isNegative} - отрицательно ли данное число.\\
			\textbf{Выход:} \code{bool isNegative} - отрицательно ли данное число.\\
			\textbf{Назначение:} возвращает булевое значение, означающее отрицательно ли данное число.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
bool Z8Number::getNeg() const {
	return isNegative;
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{inc}}  
			\textbf{\\Вход:} \code{char c} - текущее число.\\
			\textbf{Выход:} \code{char c} - следующее число.\\
			\textbf{Назначение:} возвращает число, получающееся в результате операции "+1" над текущим.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
char Z8Number::inc(char c) {
	switch (c) {
		case 'a': return 'b';
		case 'b': return 'd';
		case 'c': return 'e';
		case 'd': return 'h';
		case 'e': return 'g';
		case 'f': return 'a';
		case 'g': return 'f';
		case 'h': return 'c';
		default: throw std::invalid_argument("Invalid digit");
	}
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{dec}}  
			\textbf{\\Вход:} \code{char c} - текущее число.\\
			\textbf{Выход:} \code{char c} - предыдущее число.\\
			\textbf{Назначение:} возвращает число, получающееся в результате операции "-1" над текущим.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
char Z8Number::dec(char c) {
	switch (c) {
		case 'a': return 'f';
		case 'b': return 'a';
		case 'c': return 'h';
		case 'd': return 'b';
		case 'e': return 'c';
		case 'f': return 'g';
		case 'g': return 'e';
		case 'h': return 'd';
		default: throw std::invalid_argument("Invalid digit");
	}
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{normalize}}  
			\textbf{\\Вход:} \code{std::string s} - введенное число.\\
			\textbf{Выход:} \code{std::string r} - модуль данного числа без незначащих 'a'.\\
			\textbf{Назначение:} возвращает модуль данного числа без незначащих 'a'.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
std::string Z8Number::normalize(const std::string& s) {
	size_t i = s[0] == '-' ? 1 : 0;
	while (i < s.length() - 1 && s[i] == 'a')
	++i;
	return s.substr(i);
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{isEqual}}  
			\textbf{\\Вход:} \code{std::string a, std::string b} - числа для сравнения.\\
			\textbf{Выход:} \code{bool n} - результат сравнения чисел.\\
			\textbf{Назначение:} сравнивает два числа и возвращает true, если их модули равны, иначе false.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
bool Z8Number::isEqual(const std::string& a, const std::string& b) {
	return normalize(a) == normalize(b);
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{validate}}  
			\textbf{\\Вход:} \code{std::string s} - число на проверку корректности.\\
			\textbf{Выход:} \code{bool n} - корректно ли данное число.\\
			\textbf{Назначение:} проверяет, корретно ли данное число (не превышает ли лимиты и не содержит ли лишних символов).\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
void Z8Number::validate(const std::string& s) {
	if (s.empty()) throw std::invalid_argument("Empty number");
	if (s.size() > 8 && s[0] != '-' || s.size() > 9) throw std::invalid_argument("More than 8 digits");
	for (char c : s) {
		if (c != 'a' && c != 'b' && c != 'c' && c != 'd' &&
		c != 'e' && c != 'f' && c != 'g' && c != 'h' && c != '-')
		throw std::invalid_argument("Invalid character");
	}
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{operator==}}  
			\textbf{\\Вход:} \code{Z8Number current, Z8Number other} - числа на сравнение.\\
			\textbf{Выход:} \code{bool n} - результат сравнения двух чисел.\\
			\textbf{Назначение:} сравнивает два числа по модулю.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
bool Z8Number::operator==(const Z8Number& other) const {
	return isEqual(digits, other.digits);
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{incNumber}}  
			\textbf{\\Вход:} \code{std::string num} - число на увеличение.\\
			\textbf{Выход:} \code{std::string new} - число после увеличения.\\
			\textbf{Назначение:} увеличивает число на единицу, учитывая переносы.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
std::string Z8Number::incNumber(const std::string& num) {
	std::string res = num;
	int i = static_cast<int>(res.size()) - 1;
	while (i >= 0) {
		char old = res[i];
		res[i] = inc(old);
		if (old != 'f') { // no carry
			break;
		}
		if (i == 0) { // carrying until no need to
			res = 'b' + res;
			if (res.size() > 8)
			throw std::overflow_error("Number exceeds 8 digits");
			break;
		}
		--i;
	}
	if (normalize(res).size() > 8)
	throw std::overflow_error("Number exceeds 8 digits");
	return normalize(res);
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{decNumber}}  
			\textbf{\\Вход:} \code{std::string num} - число на уменьшение.\\
			\textbf{Выход:} \code{std::string new} - число после уменьшения.\\
			\textbf{Назначение:} уменьшает число на единицу, учитывая переносы.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
std::string Z8Number::decNumber(const std::string& num) {
	if (isEqual(num, "a"))
	throw std::domain_error("Cannot decrement zero");
	std::string res = num;
	int i = static_cast<int>(res.size()) - 1;
	while (i >= 0) {
		char old = res[i];
		res[i] = dec(old);
		if (old != 'a') { // a -> f, so we need to take one from higher
			break;
		}
		--i;
	}
	return normalize(res);
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{greaterOrEqual}}  
			\textbf{\\Вход:} \code{std::string num1, std::string num2} - числа на сравнение.\\
			\textbf{Выход:} \code{bool n} - результат сравнения чисел.\\
			\textbf{Назначение:} сравнивает два числа: больше или равно ли первое, чем второе.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
bool Z8Number::greaterOrEqual(const std::string& x, const std::string& y) {
	if (isEqual(x, y)) return true;
	if (isEqual(y, "a")) return true;
	if (isEqual(x, "a")) return false;
	try {
		subNumbers(x, y);
		return true;
	}
	catch (...) {
		return false;
	}
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{greater}}  
			\textbf{\\Вход:} \code{std::string num1, std::string num2} - числа на сравнение.\\
			\textbf{Выход:} \code{bool n} - результат сравнения чисел.\\
			\textbf{Назначение:} сравнивает два числа: больше ли первое, чем второе.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
bool greater(const Z8Number& x, const Z8Number& y) {
	if (x == y) return false;
	if (y == Z8Number("a")) return true;
	if (x == Z8Number("a")) return false;
	try {
		x - y;
		return true;
	}
	catch (...) {
		return false;
	}
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{addNumbers}}  
			\textbf{\\Вход:} \code{std::string num1, std::string num2} - числа для суммирования.\\
			\textbf{Выход:} \code{std::string result} - результат суммирования.\\
			\textbf{Назначение:} выполненяет сложение двух чисел.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
std::string Z8Number::addNumbers(const std::string& x, const std::string& y) {
	if (isEqual(y, "a")) return x;
	std::string res = x;
	std::string counter = "a";
	while (!isEqual(counter, y)) {
		res = incNumber(res);
		counter = incNumber(counter);
		if (normalize(res).size() > 8)
		throw std::overflow_error("Number exceeds 8 digits");
	}
	return res;
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{subNumbers}}  
			\textbf{\\Вход:} \code{std::string num1, std::string num2} - числа для выполнения вычитания.\\
			\textbf{Выход:} \code{std::string result} - разность.\\
			\textbf{Назначение:} выполненяет вычитание одного числа из другого, возвращает их разность.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
std::string Z8Number::subNumbers(const std::string& x, const std::string& y) {
	if (isEqual(y, "a")) return x;
	if (isEqual(x, y)) return "a";
	std::string res = x;
	std::string counter = "a";
	while (!isEqual(counter, y)) {
		res = decNumber(res);
		counter = incNumber(counter);
	}
	return res;
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{mulNumbers}}  
			\textbf{\\Вход:} \code{std::string num1, std::string num2} - числа для умножения.\\
			\textbf{Выход:} \code{std::string result} - произведение двух чисел.\\
			\textbf{Назначение:} выполненяет умножение двух чисел.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
std::string Z8Number::mulNumbers(const std::string& x, const std::string& y) {
	if (isEqual(x, "a") || isEqual(y, "a")) return "a";
	std::string res = x;
	std::string counter = "b";
	if (isEqual(y, "ba")) res = res + "a";
	else if (isEqual(y, "baa")) res = res + "aa";
	else if (isEqual(y, "baaa")) res = res + "aaa";
	else if (isEqual(y, "baaaa")) res = res + "aaaa";
	else if (isEqual(y, "baaaaa")) res = res + "aaaaa";
	else if (isEqual(y, "baaaaaa")) res = res + "aaaaaaa";
	else if (isEqual(y, "baaaaaaa")) res = res + "aaaaaaa";
	else {
		while (!isEqual(counter, y)) {
			res = addNumbers(res, x);
			counter = incNumber(counter);
		}
	}
	if (normalize(res).size() > 8)
	throw std::overflow_error("Number exceeds 8 digits");
	return res;
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{divNumbers}, \code{divide}}  
			\textbf{\\Вход:} \code{std::string num1, std::string num2} - делимое и делитель.\\
			\textbf{Выход:} \code{std::string result} - частное.\\
			\textbf{Назначение:} выполненяет деление одного числа на другое.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
std::string Z8Number::divNumbers(const std::string& x, const std::string& y, bool firstIsNeg) {
	if (isEqual(y, "a")) {
		throw std::domain_error("Division by zero");
	}
	if (isEqual(x, "a")) {
		return "a";
	}
	
	std::string quotient = "a";
	std::string remainder = x;
	
	while (greaterOrEqual(remainder, y)) {
		remainder = subNumbers(remainder, y);
		quotient = incNumber(quotient);
	}
	
	if (firstIsNeg && !isEqual(remainder, "a")) {
		quotient = incNumber(quotient);
		remainder = subNumbers(y, remainder);
	}
	
	if (isEqual(remainder, "a")) {
		return quotient;
	}
	else {
		return quotient + "(" + remainder + ")";
	}
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{operator +, -, *}}  
			\textbf{\\Вход:} \code{Z8Number num1, Z8Number num2} - числа для проведения арифметической операции.\\
			\textbf{Выход:} \code{Z8Number result} - результат выполнения арифм. операции.\\
			\textbf{Назначение:} выполнение операции над двумя числами (аналоги вызовов функций).\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
Z8Number Z8Number::operator+(const Z8Number& o) const {
	return Z8Number(addNumbers(digits, o.digits));
}
Z8Number Z8Number::operator-(const Z8Number& o) const {
	return Z8Number(subNumbers(digits, o.digits));
}
Z8Number Z8Number::operator*(const Z8Number& o) const {
	return Z8Number(mulNumbers(digits, o.digits));
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{operator =}}
			\textbf{\\Вход:} \code{Z8Number other} - число, к которому надо приравнять текущее.\\
			\textbf{Выход:} \code{Z8Number result} - обновленное текущее число.\\
			\textbf{Назначение:} присваивает значение другого числа текущему.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
Z8Number& Z8Number::operator=(const Z8Number& other) {
	digits = other.digits;
	isNegative = other.isNegative;
	return *this;
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{toString}}  
			\textbf{\\Вход:} \code{Z8Number num} - текущее число.\\
			\textbf{Выход:} \code{std::string strNum} - текущее число в строковом формате.\\
			\textbf{Назначение:} переводит число в строку.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
std::string Z8Number::toString() const {
	return digits;
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{calculate}}  
			\textbf{\\Вход:} \code{Z8Number a, Z8Number b, std::string op} - числа и операция над ними.\\
			\textbf{Выход:} \code{Z8Number result} - результат выполнения арифметической операции над числами.\\
			\textbf{Назначение:} выполнение арифметической операции над двумя числами с учетом знаков и разрядов.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
void calculate(const Z8Number& a, const Z8Number& b, std::string op) {
	std::string result;
	if (!(a.isNegative) && (!(b.isNegative))) {
		try {
			if (op == "+") {
				result = (a + b).toString();
			}
			else if (op == "-") {
				try {
					result = (a - b).toString();
				}
				catch (...) {
					result = "-" + (b - a).toString();
				}
			}
...
			\end{lstlisting}
		\end{itemize}
		
		\subsection{Реализация консольного меню}
		
		Консольное меню реализовано в файле \code{main.py}. При запуске программа выводит приветственное сообщение, после чего до каждого ввода пользователя отображает допустимые границы чисел и формат ввода.
		
		\textbf{Код тела main:}
		\begin{lstlisting}[language=C++]
std::cout << "Hello!" << std::endl;
std::string s1, s2, op;
while (true) {
	std::cout << "Enter the problem (format: <num> <operation> <num>; nums from -ffffffff to ffffffff):\n>> ";
	std::cin >> s1;
	std::cin >> op;
	std::cin >> s2;
		
	try {
		Z8Number a(s1), b(s2);
		calculate(a, b, op);
	}
	catch (...) {
		std::cerr << "Error: incorrect input" << std::endl;
	}
}
		\end{lstlisting}
		
		%\subsection{Класс \protect\code{OverflowError}}
		
		%Данный класс содержит только метод OverflowError, вызывающий ошибку %std::overflow\_error с текстом "Number exceeds 8 digits".
		
		%\textbf{Код:}
		%\begin{lstlisting}[language=C++]
%class OverflowError : public std::overflow_error {
%	public:
%	OverflowError() : std::overflow_error("Number exceeds 8 digits") {}
%};
%		\end{lstlisting}
		
		
		
		\section{Результаты работы программы}
		
		Разработанная программа имеет консольный интерфейс и предоставляет пользователю меню, позволяющее выполнять все действия. 
		
		\subsection*{Меню программы}
		
		После запуска программы пользователю предлагается ввести пример, который надо решить, в формате <число> <операция> <число>. В случае некорретного ввода (неверный формат, превышение лимитов, некорректные значения чисел) или ошибки в результате вычислений (деление на ноль, превышение лимитов) программа сообщит об этом пользователю.
		
		\subsection*{Пример работы}
		
		При запуске программы высвечивается приветственное окно и предложение ввести пример. (рис. \ref{hello}).	
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.9\textwidth]{hello.png}
			\caption[Приветственное сообщение]{Приветственное сообщение при запуске программы.}
			\label{hello}
		\end{figure}
		
		Когда пользователь введет пример и нажмет Enter, программа выведет результат вычислений (рис. \ref{fig:result}).
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.9\linewidth]{result}
			\caption[Меню]{Вывод решения примера.}
			\label{fig:result}
		\end{figure}
		
		Если пользователь сделает некорректный ввод, программа об этом сообщит и предложит ввести пример снова (рис. \ref{fig:takogo-net}).
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.9\linewidth]{takogo-net}
			\caption{Обработка некорретного пользовательского ввода.}
			\label{fig:takogo-net}
		\end{figure}
		
		Если результат операции превышает лимиты, программа так же сообщит об этом (рис. \ref{fig:of}).
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.9\linewidth]{of}
			\caption{Обработка попытки проведения операций над несуществующими мультимножествами.}
			\label{fig:of}
		\end{figure}
		
		Результаты подтвердили, что программа реализована корректно.
		
		\newpage
		\section*{Заключение}
		\addcontentsline{toc}{section}{Заключение}
		
		В ходе лабораторной работы была разработана программа, позволяющая:
		\begin{itemize}
			\item работать с арифметикой $Z_8$ с элементами (в порядке таблицы "+1") a, b, d, h, c, e, g, f:
			\begin{itemize}
				\item сложение,
				\item разность,
				\item умножение,
				\item деление,
			\end{itemize}
			\item работать с мультиразрядностью,
			\item работать с отрицательными числами,
			\item обрабатывать некорректный ввод пользователя и ограничения в операциях,	\item выполнять вычисления только в рамках данной арифметики без перевода в иные системы счисления.
		\end{itemize}
		
		Программа демонстрирует корректную реализацию всех заданных функций. 
		Программа создана по принципам ООП что удобно разделяет интерфейс и функционал класса, работающего с числами, и позволяет вносить изменения в программу легче, чем если бы она имела процедурную структуру.
		
		\paragraph{Плюсы программы.}
		\begin{itemize}
			\item Использование объектно-ориентированной парадигмы программирования, что позволяет удобно модифицировать программу.
			%\item Наличие всех основных операций над мультимножествами.
			%\item Возможность ручного и автоматического заполнения.
		\end{itemize}
		
		\paragraph{Минусы программы.}
		\begin{itemize}
			%\item Отсутствие графического интерфейса.
			\item Результаты операций не сохраняются, что позволило бы проводить несколько операций подряд.
			\item Использование стандартных контейнеров библиотеки: вручную можно было бы создать более оптимизированные контейнеры.
			\item Неоптимизированный подход к выполнению арифметических операций: всё строится на правиле +1, что означает, что при масштабировании программы и включении возможности проводить операции с большим числом разрядов, операции будут проводиться медленнее, чем при использовании большего числа матриц переходов для оптимальных вычислений.
		\end{itemize}
		
		\paragraph{Масштабирование.}  
		Используемая архитектура позволяет добавлять новые операции над числами данной алгебры (например, степени, НОК, НОД).  
		Возможна интеграция с графическим интерфейсом или веб-интерфейсом.  
		В будущем можно добавить возможность работы с несколькими операциями в одной строке.
		
		Таким образом, реализованная программа является масштабируемой и обладает потенциалом развития. Её структура позволяет расширять функциональность и использовать в более крупных программных системах.
		
		\newpage
		
		\begin{thebibliography}{99}
			\addcontentsline{toc}{section}{Список литературы}
			\bibitem{oop} Павловская Т. А., Щюпак Ю. А. С++ Объектно-ориентированное программирование: Практикум. — СПб.: Питер, 2006 — 265 с.
			\bibitem{gray} 3. Хаггарти Р. Дискретная математика для программистов — Москва: ТЕХНОСФЕРА, 2012 - 400 с.
			\bibitem{dismath} Секция "Телематика" (Электронный ресурс).\\
			URL: \url{https://tema.spbstu.ru/dismath/}\\
			(дата обращения: 24.11.2025).
		\end{thebibliography}
		
		\newpage
		
		\section*{Приложение 1. Файл Z8.h.}
		\addcontentsline{toc}{section}{Приложение 1. Файл Z8.h}
		\lstinputlisting[language=C++,caption={Файл Z8.h}]{Z8.h}
		\newpage
		
		\section*{Приложение 2. Файл Z8.cpp.}
		\addcontentsline{toc}{section}{Приложение 2. Файл Z8.cpp}
		\lstinputlisting[language=C++,caption={Файл Z8.cpp}]{Z8.cpp}
		\newpage
		
		\section*{Приложение 3. Файл main.cpp.}
		\addcontentsline{toc}{section}{Приложение 3. Файл main.cpp}
		\lstinputlisting[language=C++,caption={Файл main.cpp}]{main.cpp}
		
\end{document}
