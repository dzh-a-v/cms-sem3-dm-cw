\documentclass[14pt]{extreport}
\usepackage{indentfirst}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\addto\captionsrussian{
	\renewcommand{\contentsname}{Содержание}
}
\addto\captionsrussian{
	\renewcommand{\bibname}{Список литературы}
}
\usepackage[top = 20mm, left = 30mm, right = 15mm, bottom = 20mm]{geometry}
\setlength\parindent{12.5mm}
\renewcommand{\baselinestretch}{1.5}
\def\hrf#1{\hbox to#1{\hrulefill}}
\usepackage{ragged2e}
\usepackage{caption}
\usepackage{multicol}
\usepackage{mathtools}
\usepackage{url}
\usepackage{xurl}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{courier}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{courier}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{float}

\renewcommand\thesection{\arabic{section}}

\definecolor{bluekeywords}{rgb}{0.125,0.375,0.625}
\definecolor{greencomments}{rgb}{0.125,0.5,0.125}
\definecolor{redstrings}{rgb}{0.875,0.125,0.125}
\definecolor{graynumbers}{rgb}{0.5,0.5,0.5}
\definecolor{lightgray}{gray}{0.95}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

\newcommand{\code}[1]{\colorbox{lightgray}{\texttt{#1}}}

\lstset{
	language=C++,
	basicstyle=\ttfamily\small,
	keywordstyle=\color{bluekeywords}\bfseries,
	commentstyle=\color{greencomments},
	stringstyle=\color{redstrings},
	numberstyle=\color{graynumbers},
	numbers=left,
	numbersep=10pt,
	columns=fullflexible,
	tabsize=4,
	showspaces=false,
	showstringspaces=false,
	breaklines=true,
	backgroundcolor=\color{lightgray},
	frame=single,
	rulecolor=\color{gray!30!black},
	captionpos=b
}


\begin{document}
	\sloppy
	\thispagestyle{empty}
	\centering{
		Министерство образования и науки Российской Федерации\\
		Федеральное государственное автономное образовательное учреждение высшего образования\\
		«Санкт-Петербургский политехнический университет Петра Великого»\\[10pt]
		Институт компьютерных наук и кибербезопасности\\
		Высшая школа технологий искусственного интеллекта\\
		02.03.01 Математика и компьютерные науки\\
		\vspace{\fill}
		{\large
			Отчёт по курсовой работе\\
			по дисциплине\\
			{\Large \bf Дискретная математика}\\
			{\Large <<Калькулятор большой конечной арифметики}>>}
			\vspace{\fill}
		}
		
		\flushright
		{
			{\bf Выполнил:}\\
			студент группы 5130201/40003\\
			Джабраилов А.В.\\
			{\bf Принял:}\\
			Востров А.В.\\
			<<\hrf{2em}>> \hrf{6em} 2025~г.
		}
		
		\centering{
			Санкт-Петербург, 2025
		}
		
		\newpage
		\justifying
		\tableofcontents
		
		\newpage
		\section*{Введение}
		\addcontentsline{toc}{section}{Введение}
		\subsection*{Актуальность и цель работы}
		%\addcontentsline{toc}{subsection}{Актуальность и цель работы}
		Конечные алгебраические структуры, такие как кольца, играют фундаментальную роль в дискретной математике. Понимание принципов построения таких систем и выполнения действий в них без привлечения иных арифметик позволяет глубже понять природу вычислений и пользоваться изолированными от других систем арифметиками.
		
		В рамках данной работы рассматривается конечная арифметика $Z_8$ с заданными алгебраическими свойствами, такими как коммутативность, дистрибутивность и др. Цель работы --- составить символьный калькулятор данной арифметики, основываясь только на "малой" конечной арифметике, заданной таблицей +1. Это моделирует ситуацию, в которой вычисления должны происходить внутри изолированной системы без возможности перевода в иные, более привычные для использования.
		
		\newpage
		\section{Постановка задачи}
		
		В рамках лабораторной работы необходимо реализовать калькулятор "большой" конечной арифметики $<Z_i;+,*>$ (8 разрядов) для четырех действий (+, -, *, /) на основе "малой" конечной арифметики, где задано правило «$+1$» и выполняются свойства коммутативности (+,*), ассоциативности (+, *), дистрибутивности * относительно +, заданы аддитивная единица «a» и мультипликативная единица «b», а также выполняется свойство: $(\forall x) х*a=a$. 
		
		Необходимо реализовать программу, которая:
		\begin{itemize}
			\item поддерживает все четыре действия, а именно:
			\begin{itemize}
				\item сложение,
				\item вычитание,
				\item умножение,
				\item деление, в т.ч. с остатком,
			\end{itemize}
			\item поддерживает числа до 8 разрядов включительно (например, возможно выражение bbb + ccc),
			\item поддерживает отрицательные числа,
			\item выполняет вычисления только в рамках данной арифметики без перевода в иные системы счисления.
		\end{itemize}
		
		\newpage
		
		
		\section{Математическое описание}
		
		\subsection{Малая конечная арифметика}
		
		Рассмотрим малую конечную арифметику
		\[
		Z_8 = \{a, b, c, d, e, f, g, h\},
		\]
		в которой задана таблица «$+1$», определяющая правило перехода от элемента к следующему:
		\[
		\begin{array}{c|cccccccc}
			x      & a & b & c & d & e & f & g & h \\ \hline
			x + 1  & b & d & e & h & g & a & f & c
		\end{array}
		\]
		
		Её алгебраическая структура ---
		\[
		<Z_8; +, -, \cdot, />.
		\]
		
		Отношение порядка (диаграмма Хассе) имеет следующий вид:
		\[
		a \Rightarrow b \Rightarrow d \Rightarrow h \Rightarrow c \Rightarrow e \Rightarrow g \Rightarrow f.
		\]
		
		У данной арифметики есть следующие свойства:
		
		\begin{itemize}
		\item элемент $a$ является \textbf{аддитивной единицей}:
		\[
		\forall x \in Z_8 \quad x + a = x;
		\]
		
		\item свойство \textbf{поглощения}:
		\[
		\forall x \in Z_8 \quad x \cdot a = a;
		\]
		
		\item элемент $b$ является \textbf{мультипликативной единицей}:
		\[
		\forall x \in Z_8 \quad x \cdot b = x;
		\]
		
		\item \textbf{коммутативность}:
		\[
		\forall a, b \in Z_8 \quad a \cdot b = b \cdot a,
		\]
		\[
		\forall a, b \in Z_8 \quad a + b = b + a;
		\]
		
		\item \textbf{ассоциативность}:
		\[
		\forall a, b, c \in Z_8 \quad (a \cdot b) \cdot c = a \cdot (b \cdot c);
		\]
		
		\item \textbf{дистрибутивность}:
		\[
		(a + b) \cdot c = a \cdot c + b \cdot c.
		\]
		\end{itemize}
		
		Коммутативность и наличие мультипликативной единицы означают, что данная арифметика --- это коммутативное кольцо с единицей.
		
		Для данной арифметики были составлены таблицы сложения и умножения.
		
		\subsubsection{Сложение}
		Таблица сложения строилась на основе диаграммы Хассе и свойств данной арифметики. Примеры вычислений:
		
		\paragraph{Пример 1:} $a + d$. Так как \code{a} по условию аддитивная единица, $a + d = d$.
		
		\paragraph{Пример 2:} $g + h$. Расстояние между $h$ и $a$ (аддитивной единицей) на диаграмме Хассе равно трём, следует, что для получения результата арифметического действия нужно по диаграмме Хассе сделать три шага от \code{g} вправо. Получаем следующую последовательность: $g \Rightarrow f \Rightarrow a \Rightarrow b$. Итого: $g + h = b$.
		
	    Полученная таблица изображена ниже [\ref{tab:sum_table}]:
		
		\begin{table}[ht]
			\centering
			\caption{Таблица сложения для арифметики $Z_8$.}
			\label{tab:sum_table}
			\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
				\hline
				$\cdot$ & a & b & d & h & c & e & g & f \\ \hline
				a & a & b & d & h & c & e & g & f \\ \hline
				b & b & d & h & c & e & g & f & a \\ \hline
				d & d & h & c & e & g & f & a & b \\ \hline
				h & h & c & e & g & f & a & b & d \\ \hline
				c & c & e & g & f & a & b & d & h \\ \hline
				e & e & g & f & a & b & d & h & c \\ \hline
				g & g & f & a & b & d & h & c & e \\ \hline
				f & f & a & b & d & h & c & e & g \\ \hline
			\end{tabular}
		\end{table}
		
		\subsubsection{Умножение}
		
		Таблица умножения строилась на основе диаграммы Хассе и свойств данной арифметики, а также путём преобразования множителей до суммы чисел \code{b} (мультипликативная единица), так как по ней вычислять произведения проще всего. Примеры вычислений:
		
		\paragraph{Пример 1:} $a \cdot d$. Так как для \code{a} по условию выполняется свойство поглощения, $a \cdot d = a$.
		
		\paragraph{Пример 2:} $g \cdot h$. Расстояние между $h$ и $b$ (мультипликативной единицей) на диаграмме Хассе равно двум, следует, что $h$ больше $b$ в три раза, $\leadsto h = b + b + b$. Таким образом, можно преобразовать исходное выражение следующим образом:
		\[
		g \cdot h = g \cdot (b + b + b) = g \cdot b + g \cdot b + g \cdot b = g + g + g = c + g = d.
		\] 
		Итоговое значение --- \code{d}.
		
		Полученная таблица изображена ниже [\ref{tab:mul_table}]:
		
		\begin{table}[ht]
			\centering
			\caption{Таблица умножения для арифметики $Z_8$.}
			\label{tab:mul_table}
			\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
				\hline
		  $\cdot$ & a & b & d & h & c & e & g & f \\ \hline
				a & a & a & a & a & a & a & a & a \\ \hline
				b & a & b & b & d & h & c & e & f \\ \hline
				d & a & d & c & g & a & d & c & g \\ \hline
				h & a & h & g & b & c & f & d & e \\ \hline
				c & a & c & a & c & a & c & a & c \\ \hline
				e & a & e & d & f & c & b & g & h \\ \hline
				g & a & g & c & d & a & g & c & d \\ \hline
				f & a & f & g & e & c & h & d & b \\ \hline
			\end{tabular}
		\end{table}
		
		\subsection{Большая конечная арифметика}
		
		Так как необходимо реализовать калькулятор большой конечной арифметики на базе малой с поддержкой чисел до 8 разрядов включительно, алгебраическая структура данной арифметики следующая:
		\[
		<Z_8^8; +, -, *, />.
		\]
		
		Были построены таблицы переносов по сложению и переносов по умножению для этой арифметики.
		
		\subsubsection{Переносы по сложению}
		
		Значение переноса по сложению вычислялось по количеству переходов $f \Rightarrow a$ по диаграмме Хассе, поскольку это замыкает кольцо и означает переход от наибольшего элемента к наименьшему.
		
		\paragraph{Пример 1:} $b + d$. При решении данного примера не происходит перехода по диаграмме Хассе от \code{f} к \code{a}, так как переходы выглядят следующим образом:
		\[
		b \Rightarrow d \Rightarrow h.
		\]
		Так как нет переходов $f \Rightarrow a$, перенос по данному сложению равен $a$.
		
		\paragraph{Пример 2:} $f + h$. Переходы по диаграмме Хассе для данного примера выглядят следующим образом:
		\[
		f \Rightarrow a \Rightarrow b \Rightarrow d.
		\]
		Так как есть один переход $f \Rightarrow a$, перенос по данному сложению равен $b$.
		
		Полученная таблица переносов по сложению изображена ниже [\ref{tab:sum_carry_table}]:
		
		\begin{table}[ht]
			\centering
			\caption{Таблица переносов по сложению для арифметики $Z_8$.}
			\label{tab:sum_carry_table}
			\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
				\hline
				$\cdot$ & a & b & d & h & c & e & g & f \\ \hline
				a & a & a & a & a & a & a & a & a \\ \hline
				b & a & a & a & a & a & a & a & b \\ \hline
				d & a & a & a & a & a & a & b & b \\ \hline
				h & a & a & a & a & a & b & b & b \\ \hline
				c & a & a & a & a & b & b & b & b \\ \hline
				e & a & a & a & b & b & b & b & b \\ \hline
				g & a & a & a & b & b & b & b & b \\ \hline
				f & a & b & b & b & b & b & b & b \\ \hline
			\end{tabular}
		\end{table}
		
		\subsubsection{Переносы по умножению}
		
		Значение переноса по умножению так же вычислялось по количеству переходов $f \Rightarrow a$ по диаграмме Хассе.
		
		\paragraph{Пример 1:} $b \cdot d$. При решении данного примера не происходит перехода по диаграмме Хассе от \code{f} к \code{a}, так как решение выглядит следующим образом:
		\[
		b \cdot d = d \text{ $b$ --- мультипликативная единица.}
		\]
		Так как нет переходов $f \Rightarrow a$, перенос по данному сложению равен $a$.
		
		\paragraph{Пример 2:} $c \cdot c$. Решение данного примера выглядит следующим образом:
		\[
		c \cdot c = c \cdot (b + b + b + b) = c \cdot b + c \cdot b + c \cdot b + c \cdot b = c + c + c + c,
		\]
		Рассмотрим половину данного выражения, а именно сумму только двух \code{c}.
		\[
		c + c = c + b + b + b + b.
		\]
		Переходы по диаграмме Хассе:
		\[
		c \Rightarrow e \Rightarrow g \Rightarrow f \Rightarrow a.
		\]
		\[
		c + c = a \text{ --- один переход},
		\]
		\[
		\leadsto c + c + c + c = a + a \text{ [два перехода]} = a \text{ [дополнительных переходов нет]}.
		\]
		
		Так как есть два перехода $f \Rightarrow a$, перенос по данному умножению равен $d$.
		
		Полученная таблица переносов по умножению изображена ниже [\ref{tab:mul_carry_table}]:
		
		\begin{table}[ht]
			\centering
			\caption{Таблица переносов по умножению для арифметики $Z_8$.}
			\label{tab:mul_carry_table}
			\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
				\hline
	      $\cdot$ & a & b & d & h & c & e & g & f \\ \hline
				a & a & a & a & a & a & a & a & a \\ \hline
				b & a & a & a & a & a & a & a & a \\ \hline
				d & a & a & a & a & b & b & b & b \\ \hline
				h & a & a & a & b & b & b & d & d \\ \hline
				c & a & a & b & b & d & d & h & h \\ \hline
				e & a & a & b & b & d & h & h & c \\ \hline
				g & a & a & b & d & h & h & c & e \\ \hline
				f & a & a & b & d & h & c & e & g \\ \hline
			\end{tabular}
		\end{table}
		
		
		
		\subsection{Арифметические действия}
		Для выполнения действий (+, -, *, /) была составлена следующая логика.
		
		\subsubsection{Сложение}
		%Сложение выполняется по следующей логике.
		Пусть надо сложить числа \code{A} и \code{B}.
		\begin{enumerate}[]
			\item Выбирается наибольшее из этих двух чисел. Пусть наибольшее в данном случае \code{A}.
			\item К \code{A} прибавляется элемент \code{b} (мультипликативная единица) \code{B} раз. Прибавление единицы, в свою очередь, производится по следующей логике.
			\begin{enumerate}[label*=\arabic*]
				\item Если разряд, к которому прибавлялось \code{b}, не был равен \code{f} до прибавления, измененным остается только текущий разряд.
				\item В противном случае, \code{b} прибавляется к следующему разряду (перенос), и так до тех пор, пока не надо будет совершать перенос.
			\end{enumerate}
		\end{enumerate}
		
		Выбор наибольшего из двух чисел в шаге 1 обоснован оптимизацией вычислений, т.к. если мы складываем, например, \code{b} и \code{fffffffg}, намного быстрее прибавить один раз \code{b} к \code{fffffffg}, чем наоборот. Такой подход корректен, т.к. данная арифметика коммутативна.
		
		\subsubsection{Умножение}
		Пусть надо умножить число \code{А} на \code{В}.
		\begin{enumerate}[]
			\item Выбирается наибольшее из этих двух чисел (коммутативность). Пусть наибольшее в данном случае \code{А}.
			\item К \code{А} прибавляется \code{А} \code{В-1} раз, что реализовано через правило <<$+1$>.
		\end{enumerate}
		
		Выбор наибольшего из двух чисел в шаге 1 так же обоснован оптимизацией вычислений.
		
		\subsubsection{Вычитание}
		Вдобавок к таблице правила <<$+1$>> была создана аналогичная таблица правила <<$-1$>>.
		
		Логика вычитания реализована так же, как и сложения, за исключением того, что мы "занимаем" разряд в случае, если вычитаемый разряд на момент вычитания равен \code{a}, что вызовет переход к \code{f}, далее действие производится для старшего разряда, и так до тех пор, пока занимать разряд не придется.
		
		\subsubsection{Деление}
		%У деления было выделено два случая: общий (деление положительного на положительное, положительного на отрицательное или отрицательного на отрицательное) и частный (деление отрицательного на положительное).
		
		%\paragraph{Общий случай}
		
		Деление реализовано так же, как умножение, за исключением того, что вместо сложения мы используем вычитание из числа \code{А} числа \code{В} до тех пор, пока промежуточный	 результат вычитания не будет меньше \code{А}; ответ равен текущему результату вычитания и остатку (последнему промежуточному результату).
		
		%\paragraph{Частный случай}
		
		%Если при делении отрицательного числа на положительное остатка нет, то ответ --- целое число, на которое надо умножить делитель, чтобы получить делимое.
		
		%Если же при делении получается остаток, логика следующая:
		
		%\begin{itemize}
		%	\item увеличить модуль целой части на единицу;
		%	\item вычесть из делителя остаток --- это новый остаток;
		%	\item окончательный ответ --- увеличенный модуль и новый остаток.
		%\end{itemize}
		
		%Увеличения модуля в шаге 1 не грозит выходом за границы допустимых значений, т.к. в результате такого деления результат не может превышать делимое.
		
		\subsubsection{Отрицательные числа и действия с ними}
		Операции с отрицательными числами основываются на действях с положительными, всё заключается в изменении самого действия (например, сложение положительного и отрицательного чисел можно рассматривать как разность), а эти изменения опираются на свойства коммутативных арифметик (например, $-a + b = b + -a = b - a$).
		
		Операции с отрицательными числами проводятся по следующей логике:
		
		\textbf{Если отрицательно одно число:}
		Пусть модуль отрицательного числа \code{А}, а положительное число \code{В}.
		\begin{enumerate}[]
			\item При сложении вычитаем из модуля большего модуль меньшего; если \code{A} > \code{B}, приписываем минус в начале ответа, в противном случае нет.
			\item При вычитании складываем модули чисел.
			\item При умножении совершаем умножение и приписываеим минус.
			\item При делении:
			\begin{enumerate}[label*=\arabic*]
				\item если остатка при делении нет, приписываем минус;
				\item если остаток при делении есть, увеличиваем модуль частного на 1 и вычитаем из делителя текущий остаток.
			\end{enumerate}
		\end{enumerate}
		Увеличения модуля в шаге 4.1 не грозит выходом за границы допустимых значений, т.к. в результате такого деления результат не может превышать делимое.
		
		\textbf{Если оба числа отрицательны:}
		Пусть модули двух отрицательных чисел --- \code{A} и \code{B} соответственно порядку в выражении.
		\begin{enumerate}[]
			\item При сложении складываем модули и приписываем минус.
			\item При вычитании берем модуль большего, вычитаем из него модуль меньшего; если \code{A} > \code{B}, приписываем минус, в противном случае нет.
			\item При умножении совершаем умножение модулей.
			\item При делении совершается деление модулей.
		\end{enumerate}
		
		\subsection{Частные случаи}
		В данной алгебре присутствуют следующие частные случаи:
		\begin{itemize}
			\item $\forall x |x \neq a : x / a = \emptyset$;
			\item $a / a = [-ffffffff; ffffffff]$;
			\item если какой-то из членов выражения или результат действия превышает восемь разрядов, это является выходом за допустимые границы.
		\end{itemize}
				
		\newpage
		
		
		\section{Особенности реализации}
				
		\subsection{Реализация логики арифметики}
		
		Математическая логика программы реализована в классе \code{Z8Number}. Он содержит в себе поля для хранения данных о числе и функции для проведения действий с ними.
		
		Класс имеет два поля:
		\begin{itemize}
			\item \code{std::string digits} --- модуль числа,
			\item \code{bool isNegative} --- знак (\code{true}, если число отрицательно; иначе \code{false}).
		\end{itemize}
		
		Методы класса перечислены ниже.
		
		%В рамках данного описания числами будут называться элементы структуры $Z_8$ (\code{a}, \code{b}, ..., \code{f}).
		
		\begin{itemize}
			\item \textbf{Метод \code{getNeg}}  
			\textbf{\\Вход:} \code{bool isNegative} - отрицательно ли данное число.\\
			\textbf{Выход:} \code{bool isNegative} - отрицательно ли данное число.\\
			\textbf{Назначение:} возвращает булевое значение, означающее отрицательно ли данное число.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
bool Z8Number::getNeg() const {
	return isNegative;
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{inc}}  
			\textbf{\\Вход:} \code{char c} - текущее число.\\
			\textbf{Выход:} \code{char c} - следующее число.\\
			\textbf{Назначение:} возвращает число, получающееся в результате действия <<+1>> над текущим.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
char Z8Number::inc(char c) {
	switch (c) {
		case 'a': return 'b';
		case 'b': return 'd';
		case 'c': return 'e';
		case 'd': return 'h';
		case 'e': return 'g';
		case 'f': return 'a';
		case 'g': return 'f';
		case 'h': return 'c';
		default: throw std::invalid_argument("Invalid digit");
	}
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{dec}}  
			\textbf{\\Вход:} \code{char c} - текущее число.\\
			\textbf{Выход:} \code{char c} - предыдущее число.\\
			\textbf{Назначение:} возвращает число, получающееся в результате действия <<-1>> над текущим.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
char Z8Number::dec(char c) {
	switch (c) {
		case 'a': return 'f';
		case 'b': return 'a';
		case 'c': return 'h';
		case 'd': return 'b';
		case 'e': return 'c';
		case 'f': return 'g';
		case 'g': return 'e';
		case 'h': return 'd';
		default: throw std::invalid_argument("Invalid digit");
	}
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{normalize}}  
			\textbf{\\Вход:} \code{std::string s} - введенное число.\\
			\textbf{Выход:} \code{std::string r} - модуль данного числа без незначащих 'a'.\\
			\textbf{Назначение:} возвращает модуль данного числа без незначащих 'a'.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
std::string Z8Number::normalize(const std::string& s) {
	size_t i = s[0] == '-' ? 1 : 0;
	while (i < s.length() - 1 && s[i] == 'a')
	++i;
	return s.substr(i);
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{isEqual}}  
			\textbf{\\Вход:} \code{std::string a, std::string b} - числа для сравнения.\\
			\textbf{Выход:} \code{bool n} - результат сравнения чисел.\\
			\textbf{Назначение:} сравнивает два числа и возвращает true, если их модули равны, иначе false.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
bool Z8Number::isEqual(const std::string& a, const std::string& b) {
	return normalize(a) == normalize(b);
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{validate}}  
			\textbf{\\Вход:} \code{std::string s} - число на проверку корректности.\\
			\textbf{Выход:} \code{bool n} - корректно ли данное число.\\
			\textbf{Назначение:} проверяет, корретно ли данное число (не превышает ли лимиты и не содержит ли лишних символов).\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
void Z8Number::validate(const std::string& s) {
	if (s.empty()) throw std::invalid_argument("Empty number");
	if (s.size() > 8 && s[0] != '-' || s.size() > 9) throw std::invalid_argument("More than 8 digits");
	for (char c : s) {
		if (c != 'a' && c != 'b' && c != 'c' && c != 'd' &&
		c != 'e' && c != 'f' && c != 'g' && c != 'h' && c != '-')
		throw std::invalid_argument("Invalid character");
	}
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{operator==}}  
			\textbf{\\Вход:} \code{Z8Number current, Z8Number other} - числа на сравнение.\\
			\textbf{Выход:} \code{bool n} - результат сравнения двух чисел.\\
			\textbf{Назначение:} сравнивает два числа по модулю.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
bool Z8Number::operator==(const Z8Number& other) const {
	return isEqual(digits, other.digits);
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{incNumber}}  
			\textbf{\\Вход:} \code{std::string num} - число на увеличение.\\
			\textbf{Выход:} \code{std::string new} - число после увеличения.\\
			\textbf{Назначение:} увеличивает число на единицу, учитывая переносы.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
std::string Z8Number::incNumber(const std::string& num) {
	std::string res = num;
	int i = static_cast<int>(res.size()) - 1;
	while (i >= 0) {
		char old = res[i];
		res[i] = inc(old);
		if (old != 'f') { // no carry
			break;
		}
		if (i == 0) { // carrying until no need to
			res = 'b' + res;
			if (res.size() > 8)
			throw std::overflow_error("Number exceeds 8 digits");
			break;
		}
		--i;
	}
	if (normalize(res).size() > 8)
	throw std::overflow_error("Number exceeds 8 digits");
	return normalize(res);
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{decNumber}}  
			\textbf{\\Вход:} \code{std::string num} - число на уменьшение.\\
			\textbf{Выход:} \code{std::string new} - число после уменьшения.\\
			\textbf{Назначение:} уменьшает число на единицу, учитывая переносы.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
std::string Z8Number::decNumber(const std::string& num) {
	if (isEqual(num, "a"))
	throw std::domain_error("Cannot decrement zero");
	std::string res = num;
	int i = static_cast<int>(res.size()) - 1;
	while (i >= 0) {
		char old = res[i];
		res[i] = dec(old);
		if (old != 'a') { // a -> f, so we need to take one from higher
			break;
		}
		--i;
	}
	return normalize(res);
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{greaterOrEqual}}  
			\textbf{\\Вход:} \code{std::string num1, std::string num2} - числа на сравнение.\\
			\textbf{Выход:} \code{bool n} - результат сравнения чисел.\\
			\textbf{Назначение:} сравнивает два числа: больше или равно ли первое, чем второе.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
bool Z8Number::greaterOrEqual(const std::string& x, const std::string& y) {
	if (isEqual(x, y)) return true;
	if (isEqual(y, "a")) return true;
	if (isEqual(x, "a")) return false;
	try {
		subNumbers(x, y);
		return true;
	}
	catch (...) {
		return false;
	}
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{greater}}  
			\textbf{\\Вход:} \code{std::string num1, std::string num2} - числа на сравнение.\\
			\textbf{Выход:} \code{bool n} - результат сравнения чисел.\\
			\textbf{Назначение:} сравнивает два числа: больше ли первое, чем второе.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
bool greater(const Z8Number& x, const Z8Number& y) {
	if (x == y) return false;
	if (y == Z8Number("a")) return true;
	if (x == Z8Number("a")) return false;
	try {
		x - y;
		return true;
	}
	catch (...) {
		return false;
	}
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{addNumbers}}  
			\textbf{\\Вход:} \code{std::string num1, std::string num2} - числа для суммирования.\\
			\textbf{Выход:} \code{std::string result} - результат суммирования.\\
			\textbf{Назначение:} выполненяет сложение двух чисел.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
std::string Z8Number::addNumbers(const std::string& x, const std::string& y) {
	if (isEqual(y, "a")) return x;
	std::string res = x;
	std::string counter = "a";
	while (!isEqual(counter, y)) {
		res = incNumber(res);
		counter = incNumber(counter);
		if (normalize(res).size() > 8)
		throw std::overflow_error("Number exceeds 8 digits");
	}
	return res;
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{subNumbers}}  
			\textbf{\\Вход:} \code{std::string num1, std::string num2} - числа для выполнения вычитания.\\
			\textbf{Выход:} \code{std::string result} - разность.\\
			\textbf{Назначение:} выполненяет вычитание одного числа из другого, возвращает их разность.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
std::string Z8Number::subNumbers(const std::string& x, const std::string& y) {
	if (isEqual(y, "a")) return x;
	if (isEqual(x, y)) return "a";
	std::string res = x;
	std::string counter = "a";
	while (!isEqual(counter, y)) {
		res = decNumber(res);
		counter = incNumber(counter);
	}
	return res;
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{mulNumbers}}  
			\textbf{\\Вход:} \code{std::string num1, std::string num2} - числа для умножения.\\
			\textbf{Выход:} \code{std::string result} - произведение двух чисел.\\
			\textbf{Назначение:} выполненяет умножение двух чисел.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
std::string Z8Number::mulNumbers(const std::string& x, const std::string& y) {
	if (isEqual(x, "a") || isEqual(y, "a")) return "a";
	std::string res = x;
	std::string counter = "b";
	if (isEqual(y, "ba")) res = res + "a";
	else if (isEqual(y, "baa")) res = res + "aa";
	else if (isEqual(y, "baaa")) res = res + "aaa";
	else if (isEqual(y, "baaaa")) res = res + "aaaa";
	else if (isEqual(y, "baaaaa")) res = res + "aaaaa";
	else if (isEqual(y, "baaaaaa")) res = res + "aaaaaaa";
	else if (isEqual(y, "baaaaaaa")) res = res + "aaaaaaa";
	else {
		while (!isEqual(counter, y)) {
			res = addNumbers(res, x);
			counter = incNumber(counter);
		}
	}
	if (normalize(res).size() > 8)
	throw std::overflow_error("Number exceeds 8 digits");
	return res;
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{divNumbers}, \code{divide}}  
			\textbf{\\Вход:} \code{std::string num1, std::string num2} - делимое и делитель.\\
			\textbf{Выход:} \code{std::string result} - частное.\\
			\textbf{Назначение:} выполненяет деление одного числа на другое.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
std::string Z8Number::divNumbers(const std::string& x, const std::string& y, bool firstIsNeg) {
	if (isEqual(y, "a")) {
		if (isEqual(x, "a"))
		return "[-ffffffff; ffffffff]";
		else
		return "empty set";
	}
	if (isEqual(x, "a")) {
		return "a";
	}
	
	std::string quotient = "a";
	std::string remainder = x;
	
	while (greaterOrEqual(remainder, y)) {
		remainder = subNumbers(remainder, y);
		quotient = incNumber(quotient);
	}
	
	if (firstIsNeg && !isEqual(remainder, "a")) {
		quotient = incNumber(quotient);
		remainder = subNumbers(y, remainder);
	}
	
	if (isEqual(remainder, "a")) {
		return quotient;
	}
	else {
		return quotient + "(" + remainder + ")";
	}
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{operator +, -, *}}  
			\textbf{\\Вход:} \code{Z8Number num1, Z8Number num2} - числа для проведения арифметического действия.\\
			\textbf{Выход:} \code{Z8Number result} - результат выполнения действия.\\
			\textbf{Назначение:} выполнение действия над двумя числами (аналоги вызовов функций).\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
Z8Number Z8Number::operator+(const Z8Number& o) const {
	return Z8Number(addNumbers(digits, o.digits));
}
Z8Number Z8Number::operator-(const Z8Number& o) const {
	return Z8Number(subNumbers(digits, o.digits));
}
Z8Number Z8Number::operator*(const Z8Number& o) const {
	return Z8Number(mulNumbers(digits, o.digits));
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{operator =}}
			\textbf{\\Вход:} \code{Z8Number other} - число, к которому надо приравнять текущее.\\
			\textbf{Выход:} \code{Z8Number result} - обновленное текущее число.\\
			\textbf{Назначение:} присваивает значение другого числа текущему.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
Z8Number& Z8Number::operator=(const Z8Number& other) {
	digits = other.digits;
	isNegative = other.isNegative;
	return *this;
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{toString}}  
			\textbf{\\Вход:} \code{Z8Number num} - текущее число.\\
			\textbf{Выход:} \code{std::string strNum} - текущее число в строковом формате.\\
			\textbf{Назначение:} переводит число в строку.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
std::string Z8Number::toString() const {
	return digits;
}
			\end{lstlisting}
			
			\item \textbf{Метод \code{calculate}}  
			\textbf{\\Вход:} \code{Z8Number a, Z8Number b, std::string op} - числа и знак операции.\\
			\textbf{Выход:} \code{Z8Number result} - результат выполнения действия над числами.\\
			\textbf{Назначение:} выполнение действия над двумя числами с учетом знаков и разрядов.\\
			\textbf{Код:}
			\begin{lstlisting}[language=C++]
void calculate(const Z8Number& a, const Z8Number& b, std::string op) {
	std::string result;
	if (!(a.isNegative) && (!(b.isNegative))) {
		try {
			if (op == "+") {
				result = (a + b).toString();
			}
			else if (op == "-") {
				try {
					result = (a - b).toString();
				}
				catch (...) {
					result = "-" + (b - a).toString();
				}
			}
...
			\end{lstlisting}
		\end{itemize}
		
		\subsection{Реализация консольного меню}
		
		Консольное меню реализовано в файле \code{main.py}.
		
		\item \textbf{Функция \code{main}}  
			\textbf{\\Вход:} \code{int argc, char* argv} -- число аргументов командной строки и массив символьных указателей, каждый элемент которого указывает на аргумент командной строки.\\
			\textbf{Выход:} \code{int n} -- значение, указывающее, успешно ли завершилась программа.\\
			\textbf{Назначение:} Точка входа в программу. При запуске программа выводит приветственное сообщение, после чего до каждого ввода пользователя отображает допустимые границы чисел и формат ввода.\\		
		\textbf{Код тела main:}
		\begin{lstlisting}[language=C++]
std::cout << "Hello!" << std::endl;
std::string s1, s2, op;
while (true) {
	std::cout << "Enter the problem (format: <num> <operation> <num>; nums from -ffffffff to ffffffff):\n>> ";
	std::cin >> s1;
	std::cin >> op;
	std::cin >> s2;
		
	try {
		Z8Number a(s1), b(s2);
		calculate(a, b, op);
	}
	catch (...) {
		std::cerr << "Error: incorrect input" << std::endl;
	}
}
		\end{lstlisting}
		
		
		\newpage
		
		\section{Результаты работы программы}
		
		Разработанная программа имеет консольный интерфейс и предоставляет пользователю меню, позволяющее выполнять все действия. 
		
		\subsection*{Меню программы}
		
		После запуска программы пользователю предлагается ввести пример, который надо решить, в формате <число> <действие> <число>. В случае некорретного ввода (неверный формат, превышение лимитов, некорректные значения чисел) или частных случаев (деление на ноль, превышение лимитов) программа сообщит об этом пользователю.
		
		\subsection*{Пример работы}
		
		При запуске программы высвечивается приветственное окно и предложение ввести пример. (рис. \ref{hello}).	
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.7\textwidth]{hello.png}
			\caption[Приветственное сообщение]{Приветственное сообщение при запуске программы.}
			\label{hello}
		\end{figure}
		
		Когда пользователь введет пример и нажмет Enter, программа выведет результат вычислений.
		
		Сложение приведено на рисунке \ref{fig:sum}.
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.7\linewidth]{sum}
			\caption[Меню]{Выполнение сложения.}
			\label{fig:sum}
		\end{figure}
		
		Вычитание приведено на рисунке \ref{fig:dif}.
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.7\linewidth]{result}
			\caption[Меню]{Выполнение вычитания.}
			\label{fig:dif}
		\end{figure}
		
		Умножение приведено на рисунке \ref{fig:mul}.
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.7\linewidth]{mul}
			\caption[Меню]{Выполнение умножения.}
			\label{fig:mul}
		\end{figure}
		
		Деление приведено на рисунке \ref{fig:div}.
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.7\linewidth]{div}
			\caption[Меню]{Выполнение деления.}
			\label{fig:div}
		\end{figure}
		
		Если пользователь сделает некорректный ввод, программа об этом сообщит и предложит ввести пример снова (рис. \ref{fig:takogo-net}, \ref{fig:bdiva}).
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.7\linewidth]{takogo-net}
			\caption{Обработка некорретного пользовательского ввода.}
			\label{fig:takogo-net}
		\end{figure}
		
		Частные случаи обрабатываются программой корретно (рис. \ref{fig:of}, \ref{fig:bdiva}, \ref{fig:adiva}).
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.7\linewidth]{of}
			\caption{Обработка попытки выхода за допустимые границы.}
			\label{fig:of}
		\end{figure}
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.7\linewidth]{bdiva}
			\caption{Обработка деления ненулевого числа на \code{a}.}
			\label{fig:bdiva}
		\end{figure}
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.7\linewidth]{adiva}
			\caption{Обработка деления \code{a} на \code{a}.}
			\label{fig:adiva}
		\end{figure}
		
		
		Результаты подтвердили, что программа реализована корректно.
		
		\newpage
		\section*{Заключение}
		\addcontentsline{toc}{section}{Заключение}
		
		В ходе лабораторной работы был разработан символьный калькулятор большой конечной арифметики на основе мало конечной арифметики, позволяющий:
		\begin{itemize}
			\item работать с арифметикой $Z_8$ с элементами (в порядке таблицы <<$+1$>>) a, b, d, h, c, e, g, f:
			\begin{itemize}
				\item сложение,
				\item разность,
				\item умножение,
				\item деление,
			\end{itemize}
			\item работать с числами до 8 разрядов включительно,
			\item работать с отрицательными числами,
			\item обрабатывать некорректный ввод пользователя и ограничения в результатах арифметических действий,	
			\item выполнять вычисления только в рамках данной арифметики без перевода в иные системы счисления.
		\end{itemize}
		
		Программа демонстрирует корректную реализацию всех заданных функций. 
		Программа создана по принципам ООП что удобно разделяет интерфейс и функционал класса, работающего с числами, и позволяет вносить изменения в программу легче, чем если бы она имела процедурную структуру.
		
		\paragraph{Плюсы программы.}
		\begin{itemize}
			\item Использование объектно-ориентированной парадигмы программирования, что позволяет удобно модифицировать программу.
			\item Все вычисления производятся напрямую, без использования заранее написанных константных таблиц.
		\end{itemize}
		
		\paragraph{Минусы программы.}
		\begin{itemize}
			\item Результаты действий не сохраняются, что позволило бы проводить несколько действий подряд.
			\item Использование стандартных контейнеров библиотеки C++: вручную можно было бы создать более оптимизированные контейнеры.
			\item Неоптимизированный подход к выполнению арифметических действий: всё строится на правилах <<$+1$>> и <<$-1$>>, что означает, что при масштабировании программы и включении возможности проводить действий с бóльшим числом разрядов, действия будут проводиться медленнее, чем при использовании иного подхода для оптимальных вычислений.
		\end{itemize}
		
		\paragraph{Масштабирование.} 
		Используемая архитектура позволяет добавлять новые действия над числами данной алгебры (например, степени, НОК, НОД).
		
		Для оптимизации арифметических действий можно сгенерировать матрицы переходов, содержащие не только правила <<$+1$>> и <<$-1$>>, но и переносы разрядов. Это бы позволило не выполнять большое количество прибавлений единицы, а быстро находить ответ путём выбора нужных значений для каждого разряда.
		  
		Возможна интеграция с графическим интерфейсом или веб-интерфейсом.  
		В будущем можно добавить возможность работы с несколькими действиями в одной строке.
		
		Таким образом, реализованная программа является масштабируемой и обладает потенциалом развития. Её структура позволяет расширять функциональность и использовать в более крупных программных системах.
		
		\newpage
		
		\begin{thebibliography}{99}
			\addcontentsline{toc}{section}{Список литературы}
			\bibitem{oop} Павловская Т. А., Щюпак Ю. А. С++ Объектно-ориентированное программирование: Практикум. — СПб.: Питер, 2006 — 265 с.
			\bibitem{gray} 3. Хаггарти Р. Дискретная математика для программистов — Москва: ТЕХНОСФЕРА, 2012 - 400 с.
			\bibitem{dismath} Секция "Телематика" (Электронный ресурс).\\
			URL: \url{https://tema.spbstu.ru/dismath/}\\
			(дата обращения: 24.11.2025).
		\end{thebibliography}
		
		\newpage
		
		\section*{Приложение 1. Файл Z8.h}
		\addcontentsline{toc}{section}{Приложение 1. Файл Z8.h}
		\lstinputlisting[language=C++,caption={Файл Z8.h}]{Z8.h}
		\newpage
		
		\section*{Приложение 2. Файл Z8.cpp}
		\addcontentsline{toc}{section}{Приложение 2. Файл Z8.cpp}
		\lstinputlisting[language=C++,caption={Файл Z8.cpp}]{Z8.cpp}
		\newpage
		
		\section*{Приложение 3. Файл main.cpp}
		\addcontentsline{toc}{section}{Приложение 3. Файл main.cpp}
		\lstinputlisting[language=C++,caption={Файл main.cpp}]{main.cpp}
		
\end{document}
